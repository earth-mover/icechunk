/* Generated by cbindgen â€” do not edit */

#ifndef ICECHUNK_H
#define ICECHUNK_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

/**
 * Return codes for all icechunk_* functions.
 */
#define ICECHUNK_SUCCESS 0

#define ICECHUNK_ERROR -1

#define ICECHUNK_ERROR_NOT_FOUND -2

#define ICECHUNK_ERROR_READONLY -3

#define ICECHUNK_ERROR_NULL_ARGUMENT -4

/**
 * Opaque handle to an Icechunk storage backend.
 */
typedef struct IcechunkStorage IcechunkStorage;

/**
 * Opaque handle to an Icechunk Zarr store.
 */
typedef struct IcechunkStore IcechunkStore;

/**
 * Opaque iterator over key listings.
 */
typedef struct IcechunkStoreListIter IcechunkStoreListIter;

/**
 * Return a pointer to the thread-local error string, or null if none.
 *
 * # Safety
 * The returned pointer is valid until the next icechunk call on this thread.
 */
const char *icechunk_last_error(void);

/**
 * Create an in-memory storage backend.
 *
 * Returns null on failure (check `icechunk_last_error()`).
 */
struct IcechunkStorage *icechunk_storage_new_in_memory(void);

/**
 * Create a local filesystem storage backend.
 *
 * `path` must be a valid null-terminated UTF-8 string.
 * Returns null on failure.
 */
struct IcechunkStorage *icechunk_storage_new_local_filesystem(const char *path);

/**
 * Free a storage handle.
 *
 * Does nothing if `storage` is null.
 */
void icechunk_storage_free(struct IcechunkStorage *storage);

/**
 * Open a new store by creating a new repository and a writable session on
 * the given branch.
 *
 * `storage` is consumed (freed) by this call -- do NOT call
 * `icechunk_storage_free` on it afterwards.
 *
 * `branch` must be a valid null-terminated UTF-8 string (e.g. "main").
 * Returns null on failure (check `icechunk_last_error()`).
 */
struct IcechunkStore *icechunk_store_open(struct IcechunkStorage *storage, const char *branch);

/**
 * Free a store handle.
 *
 * Does nothing if `store` is null.
 */
void icechunk_store_free(struct IcechunkStore *store);

/**
 * Returns 1 if the store is read-only, 0 if writable, or a negative
 * error code on failure.
 */
int32_t icechunk_store_is_read_only(const struct IcechunkStore *store);

/**
 * Get the value for a Zarr key.
 *
 * On success, returns `ICECHUNK_SUCCESS`, sets `*out_data` to a
 * `malloc`-allocated buffer and `*out_len` to its length.  Caller
 * must `free()` the buffer.
 *
 * On not-found, returns `ICECHUNK_ERROR_NOT_FOUND` and sets
 * `*out_data` to null.
 * On other failures, returns `ICECHUNK_ERROR` and sets `*out_data`
 * to null.
 */
int32_t icechunk_store_get(const struct IcechunkStore *store,
                           const char *key,
                           uint8_t **out_data,
                           size_t *out_len);

/**
 * Set the value for a Zarr key.
 *
 * `data` is a pointer to `len` bytes. The data is copied; the caller
 * retains ownership of the buffer.
 *
 * Returns `ICECHUNK_SUCCESS` on success, or a negative error code on
 * failure.
 */
int32_t icechunk_store_set(const struct IcechunkStore *store,
                           const char *key,
                           const uint8_t *data,
                           size_t len);

/**
 * Check if a key exists in the store.
 *
 * Returns 1 if the key exists, 0 if not, or a negative error code on
 * failure.
 */
int32_t icechunk_store_exists(const struct IcechunkStore *store, const char *key);

/**
 * Delete a key from the store.
 *
 * Returns `ICECHUNK_SUCCESS` on success (including if the key didn't
 * exist).  Returns a negative error code on failure.
 */
int32_t icechunk_store_delete(const struct IcechunkStore *store, const char *key);

/**
 * Begin listing all keys in the store.
 *
 * Returns null on failure (check `icechunk_last_error()`).
 */
struct IcechunkStoreListIter *icechunk_store_list(const struct IcechunkStore *store);

/**
 * Begin listing keys under a prefix.
 *
 * `prefix` must be a valid null-terminated UTF-8 string.
 * Returns null on failure (check `icechunk_last_error()`).
 */
struct IcechunkStoreListIter *icechunk_store_list_prefix(const struct IcechunkStore *store,
                                                         const char *prefix);

/**
 * Begin listing directory contents under a prefix.
 *
 * `prefix` must be a valid null-terminated UTF-8 string.
 * Returns null on failure (check `icechunk_last_error()`).
 */
struct IcechunkStoreListIter *icechunk_store_list_dir(const struct IcechunkStore *store,
                                                      const char *prefix);

/**
 * Get the next key from a list iterator.
 *
 * On success, returns `ICECHUNK_SUCCESS` and sets `*out_key` to a
 * `malloc`-allocated null-terminated string.  Caller must `free()` it.
 *
 * When iteration is exhausted, returns `ICECHUNK_SUCCESS` and sets
 * `*out_key` to null.
 *
 * On error, returns a negative error code.
 */
int32_t icechunk_store_list_next(struct IcechunkStoreListIter *iter, char **out_key);

/**
 * Free a list iterator.
 *
 * Does nothing if `iter` is null.
 */
void icechunk_store_list_free(struct IcechunkStoreListIter *iter);

#endif  /* ICECHUNK_H */
