// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod gen {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_NODE_DATA: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_NODE_DATA: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_NODE_DATA: [NodeData; 3] =
        [NodeData::NONE, NodeData::Array, NodeData::Group];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct NodeData(pub u8);
    #[allow(non_upper_case_globals)]
    impl NodeData {
        pub const NONE: Self = Self(0);
        pub const Array: Self = Self(1);
        pub const Group: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::Array, Self::Group];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Array => Some("Array"),
                Self::Group => Some("Group"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for NodeData {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for NodeData {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for NodeData {
        type Output = NodeData;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for NodeData {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for NodeData {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for NodeData {}
    pub struct NodeDataUnionTableOffset {}

    // struct ObjectId12, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ObjectId12(pub [u8; 12]);
    impl Default for ObjectId12 {
        fn default() -> Self {
            Self([0; 12])
        }
    }
    impl core::fmt::Debug for ObjectId12 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("ObjectId12").field("bytes", &self.bytes()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ObjectId12 {}
    impl<'a> flatbuffers::Follow<'a> for ObjectId12 {
        type Inner = &'a ObjectId12;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ObjectId12>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ObjectId12 {
        type Inner = &'a ObjectId12;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ObjectId12>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ObjectId12 {
        type Output = ObjectId12;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const ObjectId12 as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for ObjectId12 {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ObjectId12 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(bytes: &[u8; 12]) -> Self {
            let mut s = Self([0; 12]);
            s.set_bytes(bytes);
            s
        }

        pub fn bytes(&'a self) -> flatbuffers::Array<'a, u8, 12> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_bytes(&mut self, items: &[u8; 12]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }
    }

    // struct ObjectId8, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ObjectId8(pub [u8; 8]);
    impl Default for ObjectId8 {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for ObjectId8 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("ObjectId8").field("bytes", &self.bytes()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ObjectId8 {}
    impl<'a> flatbuffers::Follow<'a> for ObjectId8 {
        type Inner = &'a ObjectId8;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ObjectId8>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ObjectId8 {
        type Inner = &'a ObjectId8;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ObjectId8>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ObjectId8 {
        type Output = ObjectId8;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const ObjectId8 as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for ObjectId8 {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ObjectId8 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(bytes: &[u8; 8]) -> Self {
            let mut s = Self([0; 8]);
            s.set_bytes(bytes);
            s
        }

        pub fn bytes(&'a self) -> flatbuffers::Array<'a, u8, 8> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_bytes(&mut self, items: &[u8; 8]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }
    }

    // struct ManifestFileInfo, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ManifestFileInfo(pub [u8; 32]);
    impl Default for ManifestFileInfo {
        fn default() -> Self {
            Self([0; 32])
        }
    }
    impl core::fmt::Debug for ManifestFileInfo {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("ManifestFileInfo")
                .field("id", &self.id())
                .field("size_bytes", &self.size_bytes())
                .field("num_chunk_refs", &self.num_chunk_refs())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ManifestFileInfo {}
    impl<'a> flatbuffers::Follow<'a> for ManifestFileInfo {
        type Inner = &'a ManifestFileInfo;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ManifestFileInfo>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ManifestFileInfo {
        type Inner = &'a ManifestFileInfo;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ManifestFileInfo>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ManifestFileInfo {
        type Output = ManifestFileInfo;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const ManifestFileInfo as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for ManifestFileInfo {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ManifestFileInfo {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: &ObjectId12, size_bytes: u64, num_chunk_refs: u32) -> Self {
            let mut s = Self([0; 32]);
            s.set_id(id);
            s.set_size_bytes(size_bytes);
            s.set_num_chunk_refs(num_chunk_refs);
            s
        }

        pub fn id(&self) -> &ObjectId12 {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[0..].as_ptr() as *const ObjectId12) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_id(&mut self, x: &ObjectId12) {
            self.0[0..0 + 12].copy_from_slice(&x.0)
        }

        pub fn size_bytes(&self) -> u64 {
            let mut mem =
                core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[16..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_size_bytes(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[16..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn num_chunk_refs(&self) -> u32 {
            let mut mem =
                core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[24..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_num_chunk_refs(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[24..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct ChunkIndexRange, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ChunkIndexRange(pub [u8; 8]);
    impl Default for ChunkIndexRange {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for ChunkIndexRange {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("ChunkIndexRange")
                .field("from", &self.from())
                .field("to", &self.to())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ChunkIndexRange {}
    impl<'a> flatbuffers::Follow<'a> for ChunkIndexRange {
        type Inner = &'a ChunkIndexRange;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ChunkIndexRange>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ChunkIndexRange {
        type Inner = &'a ChunkIndexRange;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ChunkIndexRange>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ChunkIndexRange {
        type Output = ChunkIndexRange;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const ChunkIndexRange as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(4)
        }
    }

    impl<'a> flatbuffers::Verifiable for ChunkIndexRange {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ChunkIndexRange {
        #[allow(clippy::too_many_arguments)]
        pub fn new(from: u32, to: u32) -> Self {
            let mut s = Self([0; 8]);
            s.set_from(from);
            s.set_to(to);
            s
        }

        pub fn from(&self) -> u32 {
            let mut mem =
                core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_from(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn to(&self) -> u32 {
            let mut mem =
                core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_to(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct DimensionShape, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct DimensionShape(pub [u8; 16]);
    impl Default for DimensionShape {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for DimensionShape {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("DimensionShape")
                .field("array_length", &self.array_length())
                .field("chunk_length", &self.chunk_length())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for DimensionShape {}
    impl<'a> flatbuffers::Follow<'a> for DimensionShape {
        type Inner = &'a DimensionShape;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a DimensionShape>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a DimensionShape {
        type Inner = &'a DimensionShape;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<DimensionShape>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for DimensionShape {
        type Output = DimensionShape;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const DimensionShape as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for DimensionShape {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> DimensionShape {
        #[allow(clippy::too_many_arguments)]
        pub fn new(array_length: u64, chunk_length: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_array_length(array_length);
            s.set_chunk_length(chunk_length);
            s
        }

        pub fn array_length(&self) -> u64 {
            let mut mem =
                core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_array_length(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn chunk_length(&self) -> u64 {
            let mut mem =
                core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_chunk_length(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    pub enum ChunkRefOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ChunkRef<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ChunkRef<'a> {
        type Inner = ChunkRef<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ChunkRef<'a> {
        pub const VT_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_INLINE: flatbuffers::VOffsetT = 6;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 8;
        pub const VT_LENGTH: flatbuffers::VOffsetT = 10;
        pub const VT_CHUNK_ID: flatbuffers::VOffsetT = 12;
        pub const VT_LOCATION: flatbuffers::VOffsetT = 14;
        pub const VT_CHECKSUM_ETAG: flatbuffers::VOffsetT = 16;
        pub const VT_CHECKSUM_LAST_MODIFIED: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ChunkRef { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ChunkRefArgs<'args>,
        ) -> flatbuffers::WIPOffset<ChunkRef<'bldr>> {
            let mut builder = ChunkRefBuilder::new(_fbb);
            builder.add_length(args.length);
            builder.add_offset(args.offset);
            builder.add_checksum_last_modified(args.checksum_last_modified);
            if let Some(x) = args.checksum_etag {
                builder.add_checksum_etag(x);
            }
            if let Some(x) = args.location {
                builder.add_location(x);
            }
            if let Some(x) = args.chunk_id {
                builder.add_chunk_id(x);
            }
            if let Some(x) = args.inline {
                builder.add_inline(x);
            }
            if let Some(x) = args.index {
                builder.add_index(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn index(&self) -> flatbuffers::Vector<'a, u32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                        ChunkRef::VT_INDEX,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn inline(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        ChunkRef::VT_INLINE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn offset(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(ChunkRef::VT_OFFSET, Some(0)).unwrap() }
        }
        #[inline]
        pub fn length(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(ChunkRef::VT_LENGTH, Some(0)).unwrap() }
        }
        #[inline]
        pub fn chunk_id(&self) -> Option<&'a ObjectId12> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(ChunkRef::VT_CHUNK_ID, None) }
        }
        #[inline]
        pub fn location(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    ChunkRef::VT_LOCATION,
                    None,
                )
            }
        }
        #[inline]
        pub fn checksum_etag(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    ChunkRef::VT_CHECKSUM_ETAG,
                    None,
                )
            }
        }
        #[inline]
        pub fn checksum_last_modified(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ChunkRef::VT_CHECKSUM_LAST_MODIFIED, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ChunkRef<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("index", Self::VT_INDEX, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("inline", Self::VT_INLINE, false)?
     .visit_field::<u64>("offset", Self::VT_OFFSET, false)?
     .visit_field::<u64>("length", Self::VT_LENGTH, false)?
     .visit_field::<ObjectId12>("chunk_id", Self::VT_CHUNK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("location", Self::VT_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("checksum_etag", Self::VT_CHECKSUM_ETAG, false)?
     .visit_field::<u32>("checksum_last_modified", Self::VT_CHECKSUM_LAST_MODIFIED, false)?
     .finish();
            Ok(())
        }
    }
    pub struct ChunkRefArgs<'a> {
        pub index: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
        pub inline: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub offset: u64,
        pub length: u64,
        pub chunk_id: Option<&'a ObjectId12>,
        pub location: Option<flatbuffers::WIPOffset<&'a str>>,
        pub checksum_etag: Option<flatbuffers::WIPOffset<&'a str>>,
        pub checksum_last_modified: u32,
    }
    impl<'a> Default for ChunkRefArgs<'a> {
        #[inline]
        fn default() -> Self {
            ChunkRefArgs {
                index: None, // required field
                inline: None,
                offset: 0,
                length: 0,
                chunk_id: None,
                location: None,
                checksum_etag: None,
                checksum_last_modified: 0,
            }
        }
    }

    pub struct ChunkRefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ChunkRefBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_index(
            &mut self,
            index: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ChunkRef::VT_INDEX, index);
        }
        #[inline]
        pub fn add_inline(
            &mut self,
            inline: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ChunkRef::VT_INLINE,
                inline,
            );
        }
        #[inline]
        pub fn add_offset(&mut self, offset: u64) {
            self.fbb_.push_slot::<u64>(ChunkRef::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn add_length(&mut self, length: u64) {
            self.fbb_.push_slot::<u64>(ChunkRef::VT_LENGTH, length, 0);
        }
        #[inline]
        pub fn add_chunk_id(&mut self, chunk_id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(ChunkRef::VT_CHUNK_ID, chunk_id);
        }
        #[inline]
        pub fn add_location(&mut self, location: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ChunkRef::VT_LOCATION,
                location,
            );
        }
        #[inline]
        pub fn add_checksum_etag(
            &mut self,
            checksum_etag: flatbuffers::WIPOffset<&'b str>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ChunkRef::VT_CHECKSUM_ETAG,
                checksum_etag,
            );
        }
        #[inline]
        pub fn add_checksum_last_modified(&mut self, checksum_last_modified: u32) {
            self.fbb_.push_slot::<u32>(
                ChunkRef::VT_CHECKSUM_LAST_MODIFIED,
                checksum_last_modified,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ChunkRefBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ChunkRefBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ChunkRef<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ChunkRef::VT_INDEX, "index");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ChunkRef<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ChunkRef");
            ds.field("index", &self.index());
            ds.field("inline", &self.inline());
            ds.field("offset", &self.offset());
            ds.field("length", &self.length());
            ds.field("chunk_id", &self.chunk_id());
            ds.field("location", &self.location());
            ds.field("checksum_etag", &self.checksum_etag());
            ds.field("checksum_last_modified", &self.checksum_last_modified());
            ds.finish()
        }
    }
    pub enum ArrayManifestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArrayManifest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayManifest<'a> {
        type Inner = ArrayManifest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ArrayManifest<'a> {
        pub const VT_NODE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_REFS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayManifest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ArrayManifestArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayManifest<'bldr>> {
            let mut builder = ArrayManifestBuilder::new(_fbb);
            if let Some(x) = args.refs {
                builder.add_refs(x);
            }
            if let Some(x) = args.node_id {
                builder.add_node_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn node_id(&self) -> &'a ObjectId8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<ObjectId8>(ArrayManifest::VT_NODE_ID, None).unwrap()
            }
        }
        #[inline]
        pub fn refs(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkRef<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkRef>>,
                    >>(ArrayManifest::VT_REFS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ArrayManifest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ObjectId8>("node_id", Self::VT_NODE_ID, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ChunkRef>>,
                >>("refs", Self::VT_REFS, true)?
                .finish();
            Ok(())
        }
    }
    pub struct ArrayManifestArgs<'a> {
        pub node_id: Option<&'a ObjectId8>,
        pub refs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkRef<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ArrayManifestArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayManifestArgs {
                node_id: None, // required field
                refs: None,    // required field
            }
        }
    }

    pub struct ArrayManifestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArrayManifestBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_node_id(&mut self, node_id: &ObjectId8) {
            self.fbb_.push_slot_always::<&ObjectId8>(ArrayManifest::VT_NODE_ID, node_id);
        }
        #[inline]
        pub fn add_refs(
            &mut self,
            refs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ChunkRef<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayManifest::VT_REFS,
                refs,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ArrayManifestBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ArrayManifestBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayManifest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ArrayManifest::VT_NODE_ID, "node_id");
            self.fbb_.required(o, ArrayManifest::VT_REFS, "refs");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ArrayManifest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ArrayManifest");
            ds.field("node_id", &self.node_id());
            ds.field("refs", &self.refs());
            ds.finish()
        }
    }
    pub enum ManifestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Manifest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Manifest<'a> {
        type Inner = Manifest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> Manifest<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ARRAYS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Manifest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ManifestArgs<'args>,
        ) -> flatbuffers::WIPOffset<Manifest<'bldr>> {
            let mut builder = ManifestBuilder::new(_fbb);
            if let Some(x) = args.arrays {
                builder.add_arrays(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(Manifest::VT_ID, None).unwrap() }
        }
        #[inline]
        pub fn arrays(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayManifest<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<ArrayManifest>,
                        >,
                    >>(Manifest::VT_ARRAYS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Manifest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ObjectId12>("id", Self::VT_ID, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ArrayManifest>>,
                >>("arrays", Self::VT_ARRAYS, true)?
                .finish();
            Ok(())
        }
    }
    pub struct ManifestArgs<'a> {
        pub id: Option<&'a ObjectId12>,
        pub arrays: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayManifest<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ManifestArgs<'a> {
        #[inline]
        fn default() -> Self {
            ManifestArgs {
                id: None,     // required field
                arrays: None, // required field
            }
        }
    }

    pub struct ManifestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ManifestBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(Manifest::VT_ID, id);
        }
        #[inline]
        pub fn add_arrays(
            &mut self,
            arrays: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ArrayManifest<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Manifest::VT_ARRAYS,
                arrays,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ManifestBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ManifestBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Manifest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Manifest::VT_ID, "id");
            self.fbb_.required(o, Manifest::VT_ARRAYS, "arrays");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Manifest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Manifest");
            ds.field("id", &self.id());
            ds.field("arrays", &self.arrays());
            ds.finish()
        }
    }
    pub enum MetadataItemOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MetadataItem<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MetadataItem<'a> {
        type Inner = MetadataItem<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> MetadataItem<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MetadataItem { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MetadataItemArgs<'args>,
        ) -> flatbuffers::WIPOffset<MetadataItem<'bldr>> {
            let mut builder = MetadataItemBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        MetadataItem::VT_NAME,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        MetadataItem::VT_VALUE,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for MetadataItem<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MetadataItemArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for MetadataItemArgs<'a> {
        #[inline]
        fn default() -> Self {
            MetadataItemArgs {
                name: None,  // required field
                value: None, // required field
            }
        }
    }

    pub struct MetadataItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetadataItemBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MetadataItem::VT_NAME,
                name,
            );
        }
        #[inline]
        pub fn add_value(
            &mut self,
            value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MetadataItem::VT_VALUE,
                value,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MetadataItemBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MetadataItemBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MetadataItem<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, MetadataItem::VT_NAME, "name");
            self.fbb_.required(o, MetadataItem::VT_VALUE, "value");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MetadataItem<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MetadataItem");
            ds.field("name", &self.name());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum ManifestRefOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ManifestRef<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ManifestRef<'a> {
        type Inner = ManifestRef<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ManifestRef<'a> {
        pub const VT_OBJECT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_EXTENTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ManifestRef { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ManifestRefArgs<'args>,
        ) -> flatbuffers::WIPOffset<ManifestRef<'bldr>> {
            let mut builder = ManifestRefBuilder::new(_fbb);
            if let Some(x) = args.extents {
                builder.add_extents(x);
            }
            if let Some(x) = args.object_id {
                builder.add_object_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn object_id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<ObjectId12>(ManifestRef::VT_OBJECT_ID, None).unwrap()
            }
        }
        #[inline]
        pub fn extents(&self) -> flatbuffers::Vector<'a, ChunkIndexRange> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ChunkIndexRange>>>(ManifestRef::VT_EXTENTS, None).unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ManifestRef<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<ObjectId12>("object_id", Self::VT_OBJECT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ChunkIndexRange>>>("extents", Self::VT_EXTENTS, true)?
     .finish();
            Ok(())
        }
    }
    pub struct ManifestRefArgs<'a> {
        pub object_id: Option<&'a ObjectId12>,
        pub extents:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ChunkIndexRange>>>,
    }
    impl<'a> Default for ManifestRefArgs<'a> {
        #[inline]
        fn default() -> Self {
            ManifestRefArgs {
                object_id: None, // required field
                extents: None,   // required field
            }
        }
    }

    pub struct ManifestRefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ManifestRefBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_object_id(&mut self, object_id: &ObjectId12) {
            self.fbb_
                .push_slot_always::<&ObjectId12>(ManifestRef::VT_OBJECT_ID, object_id);
        }
        #[inline]
        pub fn add_extents(
            &mut self,
            extents: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ChunkIndexRange>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ManifestRef::VT_EXTENTS,
                extents,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ManifestRefBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ManifestRefBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ManifestRef<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ManifestRef::VT_OBJECT_ID, "object_id");
            self.fbb_.required(o, ManifestRef::VT_EXTENTS, "extents");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ManifestRef<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ManifestRef");
            ds.field("object_id", &self.object_id());
            ds.field("extents", &self.extents());
            ds.finish()
        }
    }
    pub enum DimensionNameOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DimensionName<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DimensionName<'a> {
        type Inner = DimensionName<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> DimensionName<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DimensionName { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args DimensionNameArgs<'args>,
        ) -> flatbuffers::WIPOffset<DimensionName<'bldr>> {
            let mut builder = DimensionNameBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    DimensionName::VT_NAME,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for DimensionName<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DimensionNameArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for DimensionNameArgs<'a> {
        #[inline]
        fn default() -> Self {
            DimensionNameArgs { name: None }
        }
    }

    pub struct DimensionNameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionNameBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                DimensionName::VT_NAME,
                name,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> DimensionNameBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            DimensionNameBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DimensionName<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DimensionName<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DimensionName");
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum GroupNodeDataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GroupNodeData<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GroupNodeData<'a> {
        type Inner = GroupNodeData<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> GroupNodeData<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GroupNodeData { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            _args: &'args GroupNodeDataArgs,
        ) -> flatbuffers::WIPOffset<GroupNodeData<'bldr>> {
            let mut builder = GroupNodeDataBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for GroupNodeData<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct GroupNodeDataArgs {}
    impl<'a> Default for GroupNodeDataArgs {
        #[inline]
        fn default() -> Self {
            GroupNodeDataArgs {}
        }
    }

    pub struct GroupNodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GroupNodeDataBuilder<'a, 'b, A> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> GroupNodeDataBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            GroupNodeDataBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GroupNodeData<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GroupNodeData<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GroupNodeData");
            ds.finish()
        }
    }
    pub enum ArrayNodeDataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArrayNodeData<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayNodeData<'a> {
        type Inner = ArrayNodeData<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ArrayNodeData<'a> {
        pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
        pub const VT_DIMENSION_NAMES: flatbuffers::VOffsetT = 6;
        pub const VT_MANIFESTS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayNodeData { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ArrayNodeDataArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayNodeData<'bldr>> {
            let mut builder = ArrayNodeDataBuilder::new(_fbb);
            if let Some(x) = args.manifests {
                builder.add_manifests(x);
            }
            if let Some(x) = args.dimension_names {
                builder.add_dimension_names(x);
            }
            if let Some(x) = args.shape {
                builder.add_shape(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn shape(&self) -> flatbuffers::Vector<'a, DimensionShape> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, DimensionShape>>>(ArrayNodeData::VT_SHAPE, None).unwrap()
            }
        }
        #[inline]
        pub fn dimension_names(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionName<'a>>>,
        > {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionName>>,
                >>(ArrayNodeData::VT_DIMENSION_NAMES, None)
            }
        }
        #[inline]
        pub fn manifests(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ManifestRef<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<ManifestRef>,
                        >,
                    >>(ArrayNodeData::VT_MANIFESTS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ArrayNodeData<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, DimensionShape>>>("shape", Self::VT_SHAPE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DimensionName>>>>("dimension_names", Self::VT_DIMENSION_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ManifestRef>>>>("manifests", Self::VT_MANIFESTS, true)?
     .finish();
            Ok(())
        }
    }
    pub struct ArrayNodeDataArgs<'a> {
        pub shape:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, DimensionShape>>>,
        pub dimension_names: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionName<'a>>>,
            >,
        >,
        pub manifests: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ManifestRef<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ArrayNodeDataArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayNodeDataArgs {
                shape: None, // required field
                dimension_names: None,
                manifests: None, // required field
            }
        }
    }

    pub struct ArrayNodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArrayNodeDataBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_shape(
            &mut self,
            shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, DimensionShape>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayNodeData::VT_SHAPE,
                shape,
            );
        }
        #[inline]
        pub fn add_dimension_names(
            &mut self,
            dimension_names: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DimensionName<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayNodeData::VT_DIMENSION_NAMES,
                dimension_names,
            );
        }
        #[inline]
        pub fn add_manifests(
            &mut self,
            manifests: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ManifestRef<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayNodeData::VT_MANIFESTS,
                manifests,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ArrayNodeDataBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ArrayNodeDataBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayNodeData<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ArrayNodeData::VT_SHAPE, "shape");
            self.fbb_.required(o, ArrayNodeData::VT_MANIFESTS, "manifests");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ArrayNodeData<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ArrayNodeData");
            ds.field("shape", &self.shape());
            ds.field("dimension_names", &self.dimension_names());
            ds.field("manifests", &self.manifests());
            ds.finish()
        }
    }
    pub enum NodeSnapshotOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NodeSnapshot<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NodeSnapshot<'a> {
        type Inner = NodeSnapshot<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> NodeSnapshot<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_USER_DATA: flatbuffers::VOffsetT = 8;
        pub const VT_NODE_DATA_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_NODE_DATA: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NodeSnapshot { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NodeSnapshotArgs<'args>,
        ) -> flatbuffers::WIPOffset<NodeSnapshot<'bldr>> {
            let mut builder = NodeSnapshotBuilder::new(_fbb);
            if let Some(x) = args.node_data {
                builder.add_node_data(x);
            }
            if let Some(x) = args.user_data {
                builder.add_user_data(x);
            }
            if let Some(x) = args.path {
                builder.add_path(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.add_node_data_type(args.node_data_type);
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> &'a ObjectId8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId8>(NodeSnapshot::VT_ID, None).unwrap() }
        }
        #[inline]
        pub fn path(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        NodeSnapshot::VT_PATH,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn user_data(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        NodeSnapshot::VT_USER_DATA,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn node_data_type(&self) -> NodeData {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<NodeData>(
                        NodeSnapshot::VT_NODE_DATA_TYPE,
                        Some(NodeData::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn node_data(&self) -> flatbuffers::Table<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        NodeSnapshot::VT_NODE_DATA,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn node_data_as_array(&self) -> Option<ArrayNodeData<'a>> {
            if self.node_data_type() == NodeData::Array {
                let u = self.node_data();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { ArrayNodeData::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn node_data_as_group(&self) -> Option<GroupNodeData<'a>> {
            if self.node_data_type() == NodeData::Group {
                let u = self.node_data();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { GroupNodeData::init_from_table(u) })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for NodeSnapshot<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<ObjectId8>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("user_data", Self::VT_USER_DATA, true)?
     .visit_union::<NodeData, _>("node_data_type", Self::VT_NODE_DATA_TYPE, "node_data", Self::VT_NODE_DATA, true, |key, v, pos| {
        match key {
          NodeData::Array => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayNodeData>>("NodeData::Array", pos),
          NodeData::Group => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GroupNodeData>>("NodeData::Group", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct NodeSnapshotArgs<'a> {
        pub id: Option<&'a ObjectId8>,
        pub path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub user_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub node_data_type: NodeData,
        pub node_data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for NodeSnapshotArgs<'a> {
        #[inline]
        fn default() -> Self {
            NodeSnapshotArgs {
                id: None,        // required field
                path: None,      // required field
                user_data: None, // required field
                node_data_type: NodeData::NONE,
                node_data: None, // required field
            }
        }
    }

    pub struct NodeSnapshotBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NodeSnapshotBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: &ObjectId8) {
            self.fbb_.push_slot_always::<&ObjectId8>(NodeSnapshot::VT_ID, id);
        }
        #[inline]
        pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NodeSnapshot::VT_PATH,
                path,
            );
        }
        #[inline]
        pub fn add_user_data(
            &mut self,
            user_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NodeSnapshot::VT_USER_DATA,
                user_data,
            );
        }
        #[inline]
        pub fn add_node_data_type(&mut self, node_data_type: NodeData) {
            self.fbb_.push_slot::<NodeData>(
                NodeSnapshot::VT_NODE_DATA_TYPE,
                node_data_type,
                NodeData::NONE,
            );
        }
        #[inline]
        pub fn add_node_data(
            &mut self,
            node_data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NodeSnapshot::VT_NODE_DATA,
                node_data,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NodeSnapshotBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NodeSnapshotBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NodeSnapshot<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, NodeSnapshot::VT_ID, "id");
            self.fbb_.required(o, NodeSnapshot::VT_PATH, "path");
            self.fbb_.required(o, NodeSnapshot::VT_USER_DATA, "user_data");
            self.fbb_.required(o, NodeSnapshot::VT_NODE_DATA, "node_data");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NodeSnapshot<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NodeSnapshot");
            ds.field("id", &self.id());
            ds.field("path", &self.path());
            ds.field("user_data", &self.user_data());
            ds.field("node_data_type", &self.node_data_type());
            match self.node_data_type() {
                NodeData::Array => {
                    if let Some(x) = self.node_data_as_array() {
                        ds.field("node_data", &x)
                    } else {
                        ds.field("node_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                NodeData::Group => {
                    if let Some(x) = self.node_data_as_group() {
                        ds.field("node_data", &x)
                    } else {
                        ds.field("node_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("node_data", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum SnapshotOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Snapshot<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Snapshot<'a> {
        type Inner = Snapshot<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> Snapshot<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_PARENT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_NODES: flatbuffers::VOffsetT = 8;
        pub const VT_FLUSHED_AT: flatbuffers::VOffsetT = 10;
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 12;
        pub const VT_METADATA: flatbuffers::VOffsetT = 14;
        pub const VT_MANIFEST_FILES: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Snapshot { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SnapshotArgs<'args>,
        ) -> flatbuffers::WIPOffset<Snapshot<'bldr>> {
            let mut builder = SnapshotBuilder::new(_fbb);
            builder.add_flushed_at(args.flushed_at);
            if let Some(x) = args.manifest_files {
                builder.add_manifest_files(x);
            }
            if let Some(x) = args.metadata {
                builder.add_metadata(x);
            }
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            if let Some(x) = args.nodes {
                builder.add_nodes(x);
            }
            if let Some(x) = args.parent_id {
                builder.add_parent_id(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(Snapshot::VT_ID, None).unwrap() }
        }
        #[inline]
        pub fn parent_id(&self) -> Option<&'a ObjectId12> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(Snapshot::VT_PARENT_ID, None) }
        }
        #[inline]
        pub fn nodes(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeSnapshot<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<NodeSnapshot>,
                        >,
                    >>(Snapshot::VT_NODES, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn flushed_at(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Snapshot::VT_FLUSHED_AT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn message(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Snapshot::VT_MESSAGE, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn metadata(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<MetadataItem>,
                        >,
                    >>(Snapshot::VT_METADATA, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn manifest_files(&self) -> flatbuffers::Vector<'a, ManifestFileInfo> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, ManifestFileInfo>,
                    >>(Snapshot::VT_MANIFEST_FILES, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Snapshot<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<ObjectId12>("id", Self::VT_ID, true)?
     .visit_field::<ObjectId12>("parent_id", Self::VT_PARENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NodeSnapshot>>>>("nodes", Self::VT_NODES, true)?
     .visit_field::<u64>("flushed_at", Self::VT_FLUSHED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MetadataItem>>>>("metadata", Self::VT_METADATA, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ManifestFileInfo>>>("manifest_files", Self::VT_MANIFEST_FILES, true)?
     .finish();
            Ok(())
        }
    }
    pub struct SnapshotArgs<'a> {
        pub id: Option<&'a ObjectId12>,
        pub parent_id: Option<&'a ObjectId12>,
        pub nodes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeSnapshot<'a>>>,
            >,
        >,
        pub flushed_at: u64,
        pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        pub metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem<'a>>>,
            >,
        >,
        pub manifest_files:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ManifestFileInfo>>>,
    }
    impl<'a> Default for SnapshotArgs<'a> {
        #[inline]
        fn default() -> Self {
            SnapshotArgs {
                id: None, // required field
                parent_id: None,
                nodes: None, // required field
                flushed_at: 0,
                message: None,        // required field
                metadata: None,       // required field
                manifest_files: None, // required field
            }
        }
    }

    pub struct SnapshotBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SnapshotBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(Snapshot::VT_ID, id);
        }
        #[inline]
        pub fn add_parent_id(&mut self, parent_id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(Snapshot::VT_PARENT_ID, parent_id);
        }
        #[inline]
        pub fn add_nodes(
            &mut self,
            nodes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<NodeSnapshot<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Snapshot::VT_NODES, nodes);
        }
        #[inline]
        pub fn add_flushed_at(&mut self, flushed_at: u64) {
            self.fbb_.push_slot::<u64>(Snapshot::VT_FLUSHED_AT, flushed_at, 0);
        }
        #[inline]
        pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Snapshot::VT_MESSAGE,
                message,
            );
        }
        #[inline]
        pub fn add_metadata(
            &mut self,
            metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MetadataItem<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Snapshot::VT_METADATA,
                metadata,
            );
        }
        #[inline]
        pub fn add_manifest_files(
            &mut self,
            manifest_files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, ManifestFileInfo>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Snapshot::VT_MANIFEST_FILES,
                manifest_files,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SnapshotBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SnapshotBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Snapshot<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Snapshot::VT_ID, "id");
            self.fbb_.required(o, Snapshot::VT_NODES, "nodes");
            self.fbb_.required(o, Snapshot::VT_MESSAGE, "message");
            self.fbb_.required(o, Snapshot::VT_METADATA, "metadata");
            self.fbb_.required(o, Snapshot::VT_MANIFEST_FILES, "manifest_files");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Snapshot<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Snapshot");
            ds.field("id", &self.id());
            ds.field("parent_id", &self.parent_id());
            ds.field("nodes", &self.nodes());
            ds.field("flushed_at", &self.flushed_at());
            ds.field("message", &self.message());
            ds.field("metadata", &self.metadata());
            ds.field("manifest_files", &self.manifest_files());
            ds.finish()
        }
    }
    pub enum ChunkIndicesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ChunkIndices<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ChunkIndices<'a> {
        type Inner = ChunkIndices<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ChunkIndices<'a> {
        pub const VT_COORDS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ChunkIndices { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ChunkIndicesArgs<'args>,
        ) -> flatbuffers::WIPOffset<ChunkIndices<'bldr>> {
            let mut builder = ChunkIndicesBuilder::new(_fbb);
            if let Some(x) = args.coords {
                builder.add_coords(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn coords(&self) -> flatbuffers::Vector<'a, u32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                        ChunkIndices::VT_COORDS,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ChunkIndices<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("coords", Self::VT_COORDS, true)?
     .finish();
            Ok(())
        }
    }
    pub struct ChunkIndicesArgs<'a> {
        pub coords: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    }
    impl<'a> Default for ChunkIndicesArgs<'a> {
        #[inline]
        fn default() -> Self {
            ChunkIndicesArgs {
      coords: None, // required field
    }
        }
    }

    pub struct ChunkIndicesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ChunkIndicesBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_coords(
            &mut self,
            coords: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ChunkIndices::VT_COORDS,
                coords,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ChunkIndicesBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ChunkIndicesBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ChunkIndices<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ChunkIndices::VT_COORDS, "coords");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ChunkIndices<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ChunkIndices");
            ds.field("coords", &self.coords());
            ds.finish()
        }
    }
    pub enum ArrayUpdatedChunksOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArrayUpdatedChunks<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayUpdatedChunks<'a> {
        type Inner = ArrayUpdatedChunks<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ArrayUpdatedChunks<'a> {
        pub const VT_NODE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_CHUNKS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayUpdatedChunks { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ArrayUpdatedChunksArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayUpdatedChunks<'bldr>> {
            let mut builder = ArrayUpdatedChunksBuilder::new(_fbb);
            if let Some(x) = args.chunks {
                builder.add_chunks(x);
            }
            if let Some(x) = args.node_id {
                builder.add_node_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn node_id(&self) -> &'a ObjectId8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<ObjectId8>(ArrayUpdatedChunks::VT_NODE_ID, None).unwrap()
            }
        }
        #[inline]
        pub fn chunks(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkIndices<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<ChunkIndices>,
                        >,
                    >>(ArrayUpdatedChunks::VT_CHUNKS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ArrayUpdatedChunks<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ObjectId8>("node_id", Self::VT_NODE_ID, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ChunkIndices>>,
                >>("chunks", Self::VT_CHUNKS, true)?
                .finish();
            Ok(())
        }
    }
    pub struct ArrayUpdatedChunksArgs<'a> {
        pub node_id: Option<&'a ObjectId8>,
        pub chunks: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkIndices<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ArrayUpdatedChunksArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayUpdatedChunksArgs {
                node_id: None, // required field
                chunks: None,  // required field
            }
        }
    }

    pub struct ArrayUpdatedChunksBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArrayUpdatedChunksBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_node_id(&mut self, node_id: &ObjectId8) {
            self.fbb_
                .push_slot_always::<&ObjectId8>(ArrayUpdatedChunks::VT_NODE_ID, node_id);
        }
        #[inline]
        pub fn add_chunks(
            &mut self,
            chunks: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ChunkIndices<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayUpdatedChunks::VT_CHUNKS,
                chunks,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ArrayUpdatedChunksBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ArrayUpdatedChunksBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayUpdatedChunks<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ArrayUpdatedChunks::VT_NODE_ID, "node_id");
            self.fbb_.required(o, ArrayUpdatedChunks::VT_CHUNKS, "chunks");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ArrayUpdatedChunks<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ArrayUpdatedChunks");
            ds.field("node_id", &self.node_id());
            ds.field("chunks", &self.chunks());
            ds.finish()
        }
    }
    pub enum TransactionLogOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionLog<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionLog<'a> {
        type Inner = TransactionLog<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> TransactionLog<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_NEW_GROUPS: flatbuffers::VOffsetT = 6;
        pub const VT_NEW_ARRAYS: flatbuffers::VOffsetT = 8;
        pub const VT_DELETED_GROUPS: flatbuffers::VOffsetT = 10;
        pub const VT_DELETED_ARRAYS: flatbuffers::VOffsetT = 12;
        pub const VT_UPDATED_ARRAYS: flatbuffers::VOffsetT = 14;
        pub const VT_UPDATED_GROUPS: flatbuffers::VOffsetT = 16;
        pub const VT_UPDATED_CHUNKS: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionLog { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionLogArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionLog<'bldr>> {
            let mut builder = TransactionLogBuilder::new(_fbb);
            if let Some(x) = args.updated_chunks {
                builder.add_updated_chunks(x);
            }
            if let Some(x) = args.updated_groups {
                builder.add_updated_groups(x);
            }
            if let Some(x) = args.updated_arrays {
                builder.add_updated_arrays(x);
            }
            if let Some(x) = args.deleted_arrays {
                builder.add_deleted_arrays(x);
            }
            if let Some(x) = args.deleted_groups {
                builder.add_deleted_groups(x);
            }
            if let Some(x) = args.new_arrays {
                builder.add_new_arrays(x);
            }
            if let Some(x) = args.new_groups {
                builder.add_new_groups(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(TransactionLog::VT_ID, None).unwrap() }
        }
        #[inline]
        pub fn new_groups(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_NEW_GROUPS, None).unwrap()
            }
        }
        #[inline]
        pub fn new_arrays(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_NEW_ARRAYS, None).unwrap()
            }
        }
        #[inline]
        pub fn deleted_groups(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_DELETED_GROUPS, None).unwrap()
            }
        }
        #[inline]
        pub fn deleted_arrays(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_DELETED_ARRAYS, None).unwrap()
            }
        }
        #[inline]
        pub fn updated_arrays(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_UPDATED_ARRAYS, None).unwrap()
            }
        }
        #[inline]
        pub fn updated_groups(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_UPDATED_GROUPS, None).unwrap()
            }
        }
        #[inline]
        pub fn updated_chunks(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayUpdatedChunks<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<ArrayUpdatedChunks>,
                        >,
                    >>(TransactionLog::VT_UPDATED_CHUNKS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionLog<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<ObjectId12>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("new_groups", Self::VT_NEW_GROUPS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("new_arrays", Self::VT_NEW_ARRAYS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("deleted_groups", Self::VT_DELETED_GROUPS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("deleted_arrays", Self::VT_DELETED_ARRAYS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("updated_arrays", Self::VT_UPDATED_ARRAYS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("updated_groups", Self::VT_UPDATED_GROUPS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ArrayUpdatedChunks>>>>("updated_chunks", Self::VT_UPDATED_CHUNKS, true)?
     .finish();
            Ok(())
        }
    }
    pub struct TransactionLogArgs<'a> {
        pub id: Option<&'a ObjectId12>,
        pub new_groups:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub new_arrays:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub deleted_groups:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub deleted_arrays:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub updated_arrays:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub updated_groups:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub updated_chunks: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<ArrayUpdatedChunks<'a>>,
                >,
            >,
        >,
    }
    impl<'a> Default for TransactionLogArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionLogArgs {
                id: None,             // required field
                new_groups: None,     // required field
                new_arrays: None,     // required field
                deleted_groups: None, // required field
                deleted_arrays: None, // required field
                updated_arrays: None, // required field
                updated_groups: None, // required field
                updated_chunks: None, // required field
            }
        }
    }

    pub struct TransactionLogBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionLogBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(TransactionLog::VT_ID, id);
        }
        #[inline]
        pub fn add_new_groups(
            &mut self,
            new_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_NEW_GROUPS,
                new_groups,
            );
        }
        #[inline]
        pub fn add_new_arrays(
            &mut self,
            new_arrays: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_NEW_ARRAYS,
                new_arrays,
            );
        }
        #[inline]
        pub fn add_deleted_groups(
            &mut self,
            deleted_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_DELETED_GROUPS,
                deleted_groups,
            );
        }
        #[inline]
        pub fn add_deleted_arrays(
            &mut self,
            deleted_arrays: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_DELETED_ARRAYS,
                deleted_arrays,
            );
        }
        #[inline]
        pub fn add_updated_arrays(
            &mut self,
            updated_arrays: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_UPDATED_ARRAYS,
                updated_arrays,
            );
        }
        #[inline]
        pub fn add_updated_groups(
            &mut self,
            updated_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_UPDATED_GROUPS,
                updated_groups,
            );
        }
        #[inline]
        pub fn add_updated_chunks(
            &mut self,
            updated_chunks: flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'b,
                    flatbuffers::ForwardsUOffset<ArrayUpdatedChunks<'b>>,
                >,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_UPDATED_CHUNKS,
                updated_chunks,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionLogBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionLogBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionLog<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, TransactionLog::VT_ID, "id");
            self.fbb_.required(o, TransactionLog::VT_NEW_GROUPS, "new_groups");
            self.fbb_.required(o, TransactionLog::VT_NEW_ARRAYS, "new_arrays");
            self.fbb_.required(o, TransactionLog::VT_DELETED_GROUPS, "deleted_groups");
            self.fbb_.required(o, TransactionLog::VT_DELETED_ARRAYS, "deleted_arrays");
            self.fbb_.required(o, TransactionLog::VT_UPDATED_ARRAYS, "updated_arrays");
            self.fbb_.required(o, TransactionLog::VT_UPDATED_GROUPS, "updated_groups");
            self.fbb_.required(o, TransactionLog::VT_UPDATED_CHUNKS, "updated_chunks");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionLog<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionLog");
            ds.field("id", &self.id());
            ds.field("new_groups", &self.new_groups());
            ds.field("new_arrays", &self.new_arrays());
            ds.field("deleted_groups", &self.deleted_groups());
            ds.field("deleted_arrays", &self.deleted_arrays());
            ds.field("updated_arrays", &self.updated_arrays());
            ds.field("updated_groups", &self.updated_groups());
            ds.field("updated_chunks", &self.updated_chunks());
            ds.finish()
        }
    }
} // pub mod gen
