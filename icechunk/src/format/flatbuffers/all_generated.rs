// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod generated {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_NODE_DATA: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_NODE_DATA: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_NODE_DATA: [NodeData; 3] =
        [NodeData::NONE, NodeData::Array, NodeData::Group];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct NodeData(pub u8);
    #[allow(non_upper_case_globals)]
    impl NodeData {
        pub const NONE: Self = Self(0);
        pub const Array: Self = Self(1);
        pub const Group: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::Array, Self::Group];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Array => Some("Array"),
                Self::Group => Some("Group"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for NodeData {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for NodeData {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for NodeData {
        type Output = NodeData;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for NodeData {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for NodeData {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for NodeData {}
    pub struct NodeDataUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_REPO_AVAILABILITY: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_REPO_AVAILABILITY: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_REPO_AVAILABILITY: [RepoAvailability; 3] =
        [RepoAvailability::Online, RepoAvailability::ReadOnly, RepoAvailability::Offline];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct RepoAvailability(pub u8);
    #[allow(non_upper_case_globals)]
    impl RepoAvailability {
        pub const Online: Self = Self(0);
        pub const ReadOnly: Self = Self(1);
        pub const Offline: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::Online, Self::ReadOnly, Self::Offline];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Online => Some("Online"),
                Self::ReadOnly => Some("ReadOnly"),
                Self::Offline => Some("Offline"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for RepoAvailability {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for RepoAvailability {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for RepoAvailability {
        type Output = RepoAvailability;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for RepoAvailability {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for RepoAvailability {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for RepoAvailability {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_UPDATE_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_UPDATE_TYPE: u8 = 13;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_UPDATE_TYPE: [UpdateType; 14] = [
        UpdateType::NONE,
        UpdateType::RepoInitializedUpdate,
        UpdateType::RepoMigratedUpdate,
        UpdateType::ConfigChangedUpdate,
        UpdateType::TagCreatedUpdate,
        UpdateType::TagDeletedUpdate,
        UpdateType::BranchCreatedUpdate,
        UpdateType::BranchDeletedUpdate,
        UpdateType::BranchResetUpdate,
        UpdateType::NewCommitUpdate,
        UpdateType::CommitAmendedUpdate,
        UpdateType::NewDetachedSnapshotUpdate,
        UpdateType::GCRanUpdate,
        UpdateType::ExpirationRanUpdate,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct UpdateType(pub u8);
    #[allow(non_upper_case_globals)]
    impl UpdateType {
        pub const NONE: Self = Self(0);
        pub const RepoInitializedUpdate: Self = Self(1);
        pub const RepoMigratedUpdate: Self = Self(2);
        pub const ConfigChangedUpdate: Self = Self(3);
        pub const TagCreatedUpdate: Self = Self(4);
        pub const TagDeletedUpdate: Self = Self(5);
        pub const BranchCreatedUpdate: Self = Self(6);
        pub const BranchDeletedUpdate: Self = Self(7);
        pub const BranchResetUpdate: Self = Self(8);
        pub const NewCommitUpdate: Self = Self(9);
        pub const CommitAmendedUpdate: Self = Self(10);
        pub const NewDetachedSnapshotUpdate: Self = Self(11);
        pub const GCRanUpdate: Self = Self(12);
        pub const ExpirationRanUpdate: Self = Self(13);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 13;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::RepoInitializedUpdate,
            Self::RepoMigratedUpdate,
            Self::ConfigChangedUpdate,
            Self::TagCreatedUpdate,
            Self::TagDeletedUpdate,
            Self::BranchCreatedUpdate,
            Self::BranchDeletedUpdate,
            Self::BranchResetUpdate,
            Self::NewCommitUpdate,
            Self::CommitAmendedUpdate,
            Self::NewDetachedSnapshotUpdate,
            Self::GCRanUpdate,
            Self::ExpirationRanUpdate,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::RepoInitializedUpdate => Some("RepoInitializedUpdate"),
                Self::RepoMigratedUpdate => Some("RepoMigratedUpdate"),
                Self::ConfigChangedUpdate => Some("ConfigChangedUpdate"),
                Self::TagCreatedUpdate => Some("TagCreatedUpdate"),
                Self::TagDeletedUpdate => Some("TagDeletedUpdate"),
                Self::BranchCreatedUpdate => Some("BranchCreatedUpdate"),
                Self::BranchDeletedUpdate => Some("BranchDeletedUpdate"),
                Self::BranchResetUpdate => Some("BranchResetUpdate"),
                Self::NewCommitUpdate => Some("NewCommitUpdate"),
                Self::CommitAmendedUpdate => Some("CommitAmendedUpdate"),
                Self::NewDetachedSnapshotUpdate => Some("NewDetachedSnapshotUpdate"),
                Self::GCRanUpdate => Some("GCRanUpdate"),
                Self::ExpirationRanUpdate => Some("ExpirationRanUpdate"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for UpdateType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for UpdateType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for UpdateType {
        type Output = UpdateType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for UpdateType {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for UpdateType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for UpdateType {}
    pub struct UpdateTypeUnionTableOffset {}

    // struct ObjectId12, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ObjectId12(pub [u8; 12]);
    impl Default for ObjectId12 {
        fn default() -> Self {
            Self([0; 12])
        }
    }
    impl core::fmt::Debug for ObjectId12 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("ObjectId12").field("bytes", &self.bytes()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ObjectId12 {}
    impl<'a> flatbuffers::Follow<'a> for ObjectId12 {
        type Inner = &'a ObjectId12;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ObjectId12>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ObjectId12 {
        type Inner = &'a ObjectId12;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ObjectId12>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ObjectId12 {
        type Output = ObjectId12;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const ObjectId12 as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for ObjectId12 {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ObjectId12 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(bytes: &[u8; 12]) -> Self {
            let mut s = Self([0; 12]);
            s.set_bytes(bytes);
            s
        }

        pub fn bytes(&'a self) -> flatbuffers::Array<'a, u8, 12> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_bytes(&mut self, items: &[u8; 12]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }
    }

    // struct ObjectId8, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ObjectId8(pub [u8; 8]);
    impl Default for ObjectId8 {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for ObjectId8 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("ObjectId8").field("bytes", &self.bytes()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ObjectId8 {}
    impl<'a> flatbuffers::Follow<'a> for ObjectId8 {
        type Inner = &'a ObjectId8;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ObjectId8>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ObjectId8 {
        type Inner = &'a ObjectId8;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ObjectId8>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ObjectId8 {
        type Output = ObjectId8;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const ObjectId8 as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for ObjectId8 {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ObjectId8 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(bytes: &[u8; 8]) -> Self {
            let mut s = Self([0; 8]);
            s.set_bytes(bytes);
            s
        }

        pub fn bytes(&'a self) -> flatbuffers::Array<'a, u8, 8> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_bytes(&mut self, items: &[u8; 8]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }
    }

    // struct ManifestFileInfo, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ManifestFileInfo(pub [u8; 32]);
    impl Default for ManifestFileInfo {
        fn default() -> Self {
            Self([0; 32])
        }
    }
    impl core::fmt::Debug for ManifestFileInfo {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("ManifestFileInfo")
                .field("id", &self.id())
                .field("size_bytes", &self.size_bytes())
                .field("num_chunk_refs", &self.num_chunk_refs())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ManifestFileInfo {}
    impl<'a> flatbuffers::Follow<'a> for ManifestFileInfo {
        type Inner = &'a ManifestFileInfo;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ManifestFileInfo>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ManifestFileInfo {
        type Inner = &'a ManifestFileInfo;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ManifestFileInfo>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ManifestFileInfo {
        type Output = ManifestFileInfo;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const ManifestFileInfo as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for ManifestFileInfo {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ManifestFileInfo {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: &ObjectId12, size_bytes: u64, num_chunk_refs: u32) -> Self {
            let mut s = Self([0; 32]);
            s.set_id(id);
            s.set_size_bytes(size_bytes);
            s.set_num_chunk_refs(num_chunk_refs);
            s
        }

        pub fn id(&self) -> &ObjectId12 {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[0..].as_ptr() as *const ObjectId12) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_id(&mut self, x: &ObjectId12) {
            self.0[0..0 + 12].copy_from_slice(&x.0)
        }

        pub fn size_bytes(&self) -> u64 {
            let mut mem =
                core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[16..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_size_bytes(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[16..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn num_chunk_refs(&self) -> u32 {
            let mut mem =
                core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[24..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_num_chunk_refs(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[24..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct ChunkIndexRange, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ChunkIndexRange(pub [u8; 8]);
    impl Default for ChunkIndexRange {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for ChunkIndexRange {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("ChunkIndexRange")
                .field("from", &self.from())
                .field("to", &self.to())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ChunkIndexRange {}
    impl<'a> flatbuffers::Follow<'a> for ChunkIndexRange {
        type Inner = &'a ChunkIndexRange;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ChunkIndexRange>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ChunkIndexRange {
        type Inner = &'a ChunkIndexRange;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ChunkIndexRange>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ChunkIndexRange {
        type Output = ChunkIndexRange;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const ChunkIndexRange as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(4)
        }
    }

    impl<'a> flatbuffers::Verifiable for ChunkIndexRange {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ChunkIndexRange {
        #[allow(clippy::too_many_arguments)]
        pub fn new(from: u32, to: u32) -> Self {
            let mut s = Self([0; 8]);
            s.set_from(from);
            s.set_to(to);
            s
        }

        pub fn from(&self) -> u32 {
            let mut mem =
                core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_from(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn to(&self) -> u32 {
            let mut mem =
                core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_to(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct DimensionShape, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct DimensionShape(pub [u8; 16]);
    impl Default for DimensionShape {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for DimensionShape {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("DimensionShape")
                .field("array_length", &self.array_length())
                .field("chunk_length", &self.chunk_length())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for DimensionShape {}
    impl<'a> flatbuffers::Follow<'a> for DimensionShape {
        type Inner = &'a DimensionShape;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a DimensionShape>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a DimensionShape {
        type Inner = &'a DimensionShape;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<DimensionShape>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for DimensionShape {
        type Output = DimensionShape;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const DimensionShape as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for DimensionShape {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> DimensionShape {
        #[allow(clippy::too_many_arguments)]
        pub fn new(array_length: u64, chunk_length: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_array_length(array_length);
            s.set_chunk_length(chunk_length);
            s
        }

        pub fn array_length(&self) -> u64 {
            let mut mem =
                core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_array_length(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn chunk_length(&self) -> u64 {
            let mut mem =
                core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_chunk_length(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    pub enum MetadataItemOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MetadataItem<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MetadataItem<'a> {
        type Inner = MetadataItem<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> MetadataItem<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MetadataItem { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MetadataItemArgs<'args>,
        ) -> flatbuffers::WIPOffset<MetadataItem<'bldr>> {
            let mut builder = MetadataItemBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        MetadataItem::VT_NAME,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        MetadataItem::VT_VALUE,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for MetadataItem<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MetadataItemArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for MetadataItemArgs<'a> {
        #[inline]
        fn default() -> Self {
            MetadataItemArgs {
                name: None,  // required field
                value: None, // required field
            }
        }
    }

    pub struct MetadataItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetadataItemBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MetadataItem::VT_NAME,
                name,
            );
        }
        #[inline]
        pub fn add_value(
            &mut self,
            value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MetadataItem::VT_VALUE,
                value,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MetadataItemBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MetadataItemBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MetadataItem<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, MetadataItem::VT_NAME, "name");
            self.fbb_.required(o, MetadataItem::VT_VALUE, "value");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MetadataItem<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MetadataItem");
            ds.field("name", &self.name());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum ChunkRefOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ChunkRef<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ChunkRef<'a> {
        type Inner = ChunkRef<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ChunkRef<'a> {
        pub const VT_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_INLINE: flatbuffers::VOffsetT = 6;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 8;
        pub const VT_LENGTH: flatbuffers::VOffsetT = 10;
        pub const VT_CHUNK_ID: flatbuffers::VOffsetT = 12;
        pub const VT_LOCATION: flatbuffers::VOffsetT = 14;
        pub const VT_CHECKSUM_ETAG: flatbuffers::VOffsetT = 16;
        pub const VT_CHECKSUM_LAST_MODIFIED: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ChunkRef { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ChunkRefArgs<'args>,
        ) -> flatbuffers::WIPOffset<ChunkRef<'bldr>> {
            let mut builder = ChunkRefBuilder::new(_fbb);
            builder.add_length(args.length);
            builder.add_offset(args.offset);
            builder.add_checksum_last_modified(args.checksum_last_modified);
            if let Some(x) = args.checksum_etag {
                builder.add_checksum_etag(x);
            }
            if let Some(x) = args.location {
                builder.add_location(x);
            }
            if let Some(x) = args.chunk_id {
                builder.add_chunk_id(x);
            }
            if let Some(x) = args.inline {
                builder.add_inline(x);
            }
            if let Some(x) = args.index {
                builder.add_index(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn index(&self) -> flatbuffers::Vector<'a, u32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                        ChunkRef::VT_INDEX,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn inline(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        ChunkRef::VT_INLINE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn offset(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(ChunkRef::VT_OFFSET, Some(0)).unwrap() }
        }
        #[inline]
        pub fn length(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(ChunkRef::VT_LENGTH, Some(0)).unwrap() }
        }
        #[inline]
        pub fn chunk_id(&self) -> Option<&'a ObjectId12> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(ChunkRef::VT_CHUNK_ID, None) }
        }
        #[inline]
        pub fn location(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    ChunkRef::VT_LOCATION,
                    None,
                )
            }
        }
        #[inline]
        pub fn checksum_etag(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    ChunkRef::VT_CHECKSUM_ETAG,
                    None,
                )
            }
        }
        #[inline]
        pub fn checksum_last_modified(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ChunkRef::VT_CHECKSUM_LAST_MODIFIED, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ChunkRef<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("index", Self::VT_INDEX, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("inline", Self::VT_INLINE, false)?
     .visit_field::<u64>("offset", Self::VT_OFFSET, false)?
     .visit_field::<u64>("length", Self::VT_LENGTH, false)?
     .visit_field::<ObjectId12>("chunk_id", Self::VT_CHUNK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("location", Self::VT_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("checksum_etag", Self::VT_CHECKSUM_ETAG, false)?
     .visit_field::<u32>("checksum_last_modified", Self::VT_CHECKSUM_LAST_MODIFIED, false)?
     .finish();
            Ok(())
        }
    }
    pub struct ChunkRefArgs<'a> {
        pub index: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
        pub inline: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub offset: u64,
        pub length: u64,
        pub chunk_id: Option<&'a ObjectId12>,
        pub location: Option<flatbuffers::WIPOffset<&'a str>>,
        pub checksum_etag: Option<flatbuffers::WIPOffset<&'a str>>,
        pub checksum_last_modified: u32,
    }
    impl<'a> Default for ChunkRefArgs<'a> {
        #[inline]
        fn default() -> Self {
            ChunkRefArgs {
                index: None, // required field
                inline: None,
                offset: 0,
                length: 0,
                chunk_id: None,
                location: None,
                checksum_etag: None,
                checksum_last_modified: 0,
            }
        }
    }

    pub struct ChunkRefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ChunkRefBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_index(
            &mut self,
            index: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ChunkRef::VT_INDEX, index);
        }
        #[inline]
        pub fn add_inline(
            &mut self,
            inline: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ChunkRef::VT_INLINE,
                inline,
            );
        }
        #[inline]
        pub fn add_offset(&mut self, offset: u64) {
            self.fbb_.push_slot::<u64>(ChunkRef::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn add_length(&mut self, length: u64) {
            self.fbb_.push_slot::<u64>(ChunkRef::VT_LENGTH, length, 0);
        }
        #[inline]
        pub fn add_chunk_id(&mut self, chunk_id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(ChunkRef::VT_CHUNK_ID, chunk_id);
        }
        #[inline]
        pub fn add_location(&mut self, location: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ChunkRef::VT_LOCATION,
                location,
            );
        }
        #[inline]
        pub fn add_checksum_etag(
            &mut self,
            checksum_etag: flatbuffers::WIPOffset<&'b str>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ChunkRef::VT_CHECKSUM_ETAG,
                checksum_etag,
            );
        }
        #[inline]
        pub fn add_checksum_last_modified(&mut self, checksum_last_modified: u32) {
            self.fbb_.push_slot::<u32>(
                ChunkRef::VT_CHECKSUM_LAST_MODIFIED,
                checksum_last_modified,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ChunkRefBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ChunkRefBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ChunkRef<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ChunkRef::VT_INDEX, "index");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ChunkRef<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ChunkRef");
            ds.field("index", &self.index());
            ds.field("inline", &self.inline());
            ds.field("offset", &self.offset());
            ds.field("length", &self.length());
            ds.field("chunk_id", &self.chunk_id());
            ds.field("location", &self.location());
            ds.field("checksum_etag", &self.checksum_etag());
            ds.field("checksum_last_modified", &self.checksum_last_modified());
            ds.finish()
        }
    }
    pub enum ArrayManifestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArrayManifest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayManifest<'a> {
        type Inner = ArrayManifest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ArrayManifest<'a> {
        pub const VT_NODE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_REFS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayManifest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ArrayManifestArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayManifest<'bldr>> {
            let mut builder = ArrayManifestBuilder::new(_fbb);
            if let Some(x) = args.refs {
                builder.add_refs(x);
            }
            if let Some(x) = args.node_id {
                builder.add_node_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn node_id(&self) -> &'a ObjectId8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<ObjectId8>(ArrayManifest::VT_NODE_ID, None).unwrap()
            }
        }
        #[inline]
        pub fn refs(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkRef<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkRef>>,
                    >>(ArrayManifest::VT_REFS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ArrayManifest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ObjectId8>("node_id", Self::VT_NODE_ID, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ChunkRef>>,
                >>("refs", Self::VT_REFS, true)?
                .finish();
            Ok(())
        }
    }
    pub struct ArrayManifestArgs<'a> {
        pub node_id: Option<&'a ObjectId8>,
        pub refs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkRef<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ArrayManifestArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayManifestArgs {
                node_id: None, // required field
                refs: None,    // required field
            }
        }
    }

    pub struct ArrayManifestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArrayManifestBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_node_id(&mut self, node_id: &ObjectId8) {
            self.fbb_.push_slot_always::<&ObjectId8>(ArrayManifest::VT_NODE_ID, node_id);
        }
        #[inline]
        pub fn add_refs(
            &mut self,
            refs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ChunkRef<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayManifest::VT_REFS,
                refs,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ArrayManifestBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ArrayManifestBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayManifest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ArrayManifest::VT_NODE_ID, "node_id");
            self.fbb_.required(o, ArrayManifest::VT_REFS, "refs");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ArrayManifest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ArrayManifest");
            ds.field("node_id", &self.node_id());
            ds.field("refs", &self.refs());
            ds.finish()
        }
    }
    pub enum ManifestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Manifest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Manifest<'a> {
        type Inner = Manifest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> Manifest<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ARRAYS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Manifest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ManifestArgs<'args>,
        ) -> flatbuffers::WIPOffset<Manifest<'bldr>> {
            let mut builder = ManifestBuilder::new(_fbb);
            if let Some(x) = args.arrays {
                builder.add_arrays(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(Manifest::VT_ID, None).unwrap() }
        }
        #[inline]
        pub fn arrays(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayManifest<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<ArrayManifest>,
                        >,
                    >>(Manifest::VT_ARRAYS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Manifest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ObjectId12>("id", Self::VT_ID, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ArrayManifest>>,
                >>("arrays", Self::VT_ARRAYS, true)?
                .finish();
            Ok(())
        }
    }
    pub struct ManifestArgs<'a> {
        pub id: Option<&'a ObjectId12>,
        pub arrays: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayManifest<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ManifestArgs<'a> {
        #[inline]
        fn default() -> Self {
            ManifestArgs {
                id: None,     // required field
                arrays: None, // required field
            }
        }
    }

    pub struct ManifestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ManifestBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(Manifest::VT_ID, id);
        }
        #[inline]
        pub fn add_arrays(
            &mut self,
            arrays: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ArrayManifest<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Manifest::VT_ARRAYS,
                arrays,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ManifestBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ManifestBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Manifest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Manifest::VT_ID, "id");
            self.fbb_.required(o, Manifest::VT_ARRAYS, "arrays");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Manifest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Manifest");
            ds.field("id", &self.id());
            ds.field("arrays", &self.arrays());
            ds.finish()
        }
    }
    pub enum ManifestRefOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ManifestRef<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ManifestRef<'a> {
        type Inner = ManifestRef<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ManifestRef<'a> {
        pub const VT_OBJECT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_EXTENTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ManifestRef { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ManifestRefArgs<'args>,
        ) -> flatbuffers::WIPOffset<ManifestRef<'bldr>> {
            let mut builder = ManifestRefBuilder::new(_fbb);
            if let Some(x) = args.extents {
                builder.add_extents(x);
            }
            if let Some(x) = args.object_id {
                builder.add_object_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn object_id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<ObjectId12>(ManifestRef::VT_OBJECT_ID, None).unwrap()
            }
        }
        #[inline]
        pub fn extents(&self) -> flatbuffers::Vector<'a, ChunkIndexRange> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ChunkIndexRange>>>(ManifestRef::VT_EXTENTS, None).unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ManifestRef<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<ObjectId12>("object_id", Self::VT_OBJECT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ChunkIndexRange>>>("extents", Self::VT_EXTENTS, true)?
     .finish();
            Ok(())
        }
    }
    pub struct ManifestRefArgs<'a> {
        pub object_id: Option<&'a ObjectId12>,
        pub extents:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ChunkIndexRange>>>,
    }
    impl<'a> Default for ManifestRefArgs<'a> {
        #[inline]
        fn default() -> Self {
            ManifestRefArgs {
                object_id: None, // required field
                extents: None,   // required field
            }
        }
    }

    pub struct ManifestRefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ManifestRefBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_object_id(&mut self, object_id: &ObjectId12) {
            self.fbb_
                .push_slot_always::<&ObjectId12>(ManifestRef::VT_OBJECT_ID, object_id);
        }
        #[inline]
        pub fn add_extents(
            &mut self,
            extents: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ChunkIndexRange>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ManifestRef::VT_EXTENTS,
                extents,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ManifestRefBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ManifestRefBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ManifestRef<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ManifestRef::VT_OBJECT_ID, "object_id");
            self.fbb_.required(o, ManifestRef::VT_EXTENTS, "extents");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ManifestRef<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ManifestRef");
            ds.field("object_id", &self.object_id());
            ds.field("extents", &self.extents());
            ds.finish()
        }
    }
    pub enum DimensionNameOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DimensionName<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DimensionName<'a> {
        type Inner = DimensionName<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> DimensionName<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DimensionName { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args DimensionNameArgs<'args>,
        ) -> flatbuffers::WIPOffset<DimensionName<'bldr>> {
            let mut builder = DimensionNameBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    DimensionName::VT_NAME,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for DimensionName<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DimensionNameArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for DimensionNameArgs<'a> {
        #[inline]
        fn default() -> Self {
            DimensionNameArgs { name: None }
        }
    }

    pub struct DimensionNameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionNameBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                DimensionName::VT_NAME,
                name,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> DimensionNameBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            DimensionNameBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DimensionName<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DimensionName<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DimensionName");
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum GroupNodeDataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GroupNodeData<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GroupNodeData<'a> {
        type Inner = GroupNodeData<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> GroupNodeData<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GroupNodeData { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            _args: &'args GroupNodeDataArgs,
        ) -> flatbuffers::WIPOffset<GroupNodeData<'bldr>> {
            let mut builder = GroupNodeDataBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for GroupNodeData<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct GroupNodeDataArgs {}
    impl<'a> Default for GroupNodeDataArgs {
        #[inline]
        fn default() -> Self {
            GroupNodeDataArgs {}
        }
    }

    pub struct GroupNodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GroupNodeDataBuilder<'a, 'b, A> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> GroupNodeDataBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            GroupNodeDataBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GroupNodeData<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GroupNodeData<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GroupNodeData");
            ds.finish()
        }
    }
    pub enum ArrayNodeDataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArrayNodeData<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayNodeData<'a> {
        type Inner = ArrayNodeData<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ArrayNodeData<'a> {
        pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
        pub const VT_DIMENSION_NAMES: flatbuffers::VOffsetT = 6;
        pub const VT_MANIFESTS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayNodeData { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ArrayNodeDataArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayNodeData<'bldr>> {
            let mut builder = ArrayNodeDataBuilder::new(_fbb);
            if let Some(x) = args.manifests {
                builder.add_manifests(x);
            }
            if let Some(x) = args.dimension_names {
                builder.add_dimension_names(x);
            }
            if let Some(x) = args.shape {
                builder.add_shape(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn shape(&self) -> flatbuffers::Vector<'a, DimensionShape> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, DimensionShape>>>(ArrayNodeData::VT_SHAPE, None).unwrap()
            }
        }
        #[inline]
        pub fn dimension_names(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionName<'a>>>,
        > {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionName>>,
                >>(ArrayNodeData::VT_DIMENSION_NAMES, None)
            }
        }
        #[inline]
        pub fn manifests(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ManifestRef<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<ManifestRef>,
                        >,
                    >>(ArrayNodeData::VT_MANIFESTS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ArrayNodeData<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, DimensionShape>>>("shape", Self::VT_SHAPE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DimensionName>>>>("dimension_names", Self::VT_DIMENSION_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ManifestRef>>>>("manifests", Self::VT_MANIFESTS, true)?
     .finish();
            Ok(())
        }
    }
    pub struct ArrayNodeDataArgs<'a> {
        pub shape:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, DimensionShape>>>,
        pub dimension_names: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionName<'a>>>,
            >,
        >,
        pub manifests: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ManifestRef<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ArrayNodeDataArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayNodeDataArgs {
                shape: None, // required field
                dimension_names: None,
                manifests: None, // required field
            }
        }
    }

    pub struct ArrayNodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArrayNodeDataBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_shape(
            &mut self,
            shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, DimensionShape>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayNodeData::VT_SHAPE,
                shape,
            );
        }
        #[inline]
        pub fn add_dimension_names(
            &mut self,
            dimension_names: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DimensionName<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayNodeData::VT_DIMENSION_NAMES,
                dimension_names,
            );
        }
        #[inline]
        pub fn add_manifests(
            &mut self,
            manifests: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ManifestRef<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayNodeData::VT_MANIFESTS,
                manifests,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ArrayNodeDataBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ArrayNodeDataBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayNodeData<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ArrayNodeData::VT_SHAPE, "shape");
            self.fbb_.required(o, ArrayNodeData::VT_MANIFESTS, "manifests");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ArrayNodeData<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ArrayNodeData");
            ds.field("shape", &self.shape());
            ds.field("dimension_names", &self.dimension_names());
            ds.field("manifests", &self.manifests());
            ds.finish()
        }
    }
    pub enum NodeSnapshotOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NodeSnapshot<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NodeSnapshot<'a> {
        type Inner = NodeSnapshot<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> NodeSnapshot<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_USER_DATA: flatbuffers::VOffsetT = 8;
        pub const VT_NODE_DATA_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_NODE_DATA: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NodeSnapshot { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NodeSnapshotArgs<'args>,
        ) -> flatbuffers::WIPOffset<NodeSnapshot<'bldr>> {
            let mut builder = NodeSnapshotBuilder::new(_fbb);
            if let Some(x) = args.node_data {
                builder.add_node_data(x);
            }
            if let Some(x) = args.user_data {
                builder.add_user_data(x);
            }
            if let Some(x) = args.path {
                builder.add_path(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.add_node_data_type(args.node_data_type);
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> &'a ObjectId8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId8>(NodeSnapshot::VT_ID, None).unwrap() }
        }
        #[inline]
        pub fn path(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        NodeSnapshot::VT_PATH,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn user_data(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        NodeSnapshot::VT_USER_DATA,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn node_data_type(&self) -> NodeData {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<NodeData>(
                        NodeSnapshot::VT_NODE_DATA_TYPE,
                        Some(NodeData::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn node_data(&self) -> flatbuffers::Table<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        NodeSnapshot::VT_NODE_DATA,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn node_data_as_array(&self) -> Option<ArrayNodeData<'a>> {
            if self.node_data_type() == NodeData::Array {
                let u = self.node_data();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { ArrayNodeData::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn node_data_as_group(&self) -> Option<GroupNodeData<'a>> {
            if self.node_data_type() == NodeData::Group {
                let u = self.node_data();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { GroupNodeData::init_from_table(u) })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for NodeSnapshot<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<ObjectId8>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("user_data", Self::VT_USER_DATA, true)?
     .visit_union::<NodeData, _>("node_data_type", Self::VT_NODE_DATA_TYPE, "node_data", Self::VT_NODE_DATA, true, |key, v, pos| {
        match key {
          NodeData::Array => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayNodeData>>("NodeData::Array", pos),
          NodeData::Group => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GroupNodeData>>("NodeData::Group", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct NodeSnapshotArgs<'a> {
        pub id: Option<&'a ObjectId8>,
        pub path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub user_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub node_data_type: NodeData,
        pub node_data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for NodeSnapshotArgs<'a> {
        #[inline]
        fn default() -> Self {
            NodeSnapshotArgs {
                id: None,        // required field
                path: None,      // required field
                user_data: None, // required field
                node_data_type: NodeData::NONE,
                node_data: None, // required field
            }
        }
    }

    pub struct NodeSnapshotBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NodeSnapshotBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: &ObjectId8) {
            self.fbb_.push_slot_always::<&ObjectId8>(NodeSnapshot::VT_ID, id);
        }
        #[inline]
        pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NodeSnapshot::VT_PATH,
                path,
            );
        }
        #[inline]
        pub fn add_user_data(
            &mut self,
            user_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NodeSnapshot::VT_USER_DATA,
                user_data,
            );
        }
        #[inline]
        pub fn add_node_data_type(&mut self, node_data_type: NodeData) {
            self.fbb_.push_slot::<NodeData>(
                NodeSnapshot::VT_NODE_DATA_TYPE,
                node_data_type,
                NodeData::NONE,
            );
        }
        #[inline]
        pub fn add_node_data(
            &mut self,
            node_data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NodeSnapshot::VT_NODE_DATA,
                node_data,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NodeSnapshotBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NodeSnapshotBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NodeSnapshot<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, NodeSnapshot::VT_ID, "id");
            self.fbb_.required(o, NodeSnapshot::VT_PATH, "path");
            self.fbb_.required(o, NodeSnapshot::VT_USER_DATA, "user_data");
            self.fbb_.required(o, NodeSnapshot::VT_NODE_DATA, "node_data");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NodeSnapshot<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NodeSnapshot");
            ds.field("id", &self.id());
            ds.field("path", &self.path());
            ds.field("user_data", &self.user_data());
            ds.field("node_data_type", &self.node_data_type());
            match self.node_data_type() {
                NodeData::Array => {
                    if let Some(x) = self.node_data_as_array() {
                        ds.field("node_data", &x)
                    } else {
                        ds.field("node_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                NodeData::Group => {
                    if let Some(x) = self.node_data_as_group() {
                        ds.field("node_data", &x)
                    } else {
                        ds.field("node_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("node_data", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum SnapshotOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Snapshot<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Snapshot<'a> {
        type Inner = Snapshot<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> Snapshot<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_PARENT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_NODES: flatbuffers::VOffsetT = 8;
        pub const VT_FLUSHED_AT: flatbuffers::VOffsetT = 10;
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 12;
        pub const VT_METADATA: flatbuffers::VOffsetT = 14;
        pub const VT_MANIFEST_FILES: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Snapshot { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SnapshotArgs<'args>,
        ) -> flatbuffers::WIPOffset<Snapshot<'bldr>> {
            let mut builder = SnapshotBuilder::new(_fbb);
            builder.add_flushed_at(args.flushed_at);
            if let Some(x) = args.manifest_files {
                builder.add_manifest_files(x);
            }
            if let Some(x) = args.metadata {
                builder.add_metadata(x);
            }
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            if let Some(x) = args.nodes {
                builder.add_nodes(x);
            }
            if let Some(x) = args.parent_id {
                builder.add_parent_id(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(Snapshot::VT_ID, None).unwrap() }
        }
        #[inline]
        pub fn parent_id(&self) -> Option<&'a ObjectId12> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(Snapshot::VT_PARENT_ID, None) }
        }
        #[inline]
        pub fn nodes(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeSnapshot<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<NodeSnapshot>,
                        >,
                    >>(Snapshot::VT_NODES, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn flushed_at(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Snapshot::VT_FLUSHED_AT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn message(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Snapshot::VT_MESSAGE, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn metadata(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<MetadataItem>,
                        >,
                    >>(Snapshot::VT_METADATA, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn manifest_files(&self) -> flatbuffers::Vector<'a, ManifestFileInfo> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, ManifestFileInfo>,
                    >>(Snapshot::VT_MANIFEST_FILES, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Snapshot<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<ObjectId12>("id", Self::VT_ID, true)?
     .visit_field::<ObjectId12>("parent_id", Self::VT_PARENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NodeSnapshot>>>>("nodes", Self::VT_NODES, true)?
     .visit_field::<u64>("flushed_at", Self::VT_FLUSHED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MetadataItem>>>>("metadata", Self::VT_METADATA, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ManifestFileInfo>>>("manifest_files", Self::VT_MANIFEST_FILES, true)?
     .finish();
            Ok(())
        }
    }
    pub struct SnapshotArgs<'a> {
        pub id: Option<&'a ObjectId12>,
        pub parent_id: Option<&'a ObjectId12>,
        pub nodes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeSnapshot<'a>>>,
            >,
        >,
        pub flushed_at: u64,
        pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        pub metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem<'a>>>,
            >,
        >,
        pub manifest_files:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ManifestFileInfo>>>,
    }
    impl<'a> Default for SnapshotArgs<'a> {
        #[inline]
        fn default() -> Self {
            SnapshotArgs {
                id: None, // required field
                parent_id: None,
                nodes: None, // required field
                flushed_at: 0,
                message: None,        // required field
                metadata: None,       // required field
                manifest_files: None, // required field
            }
        }
    }

    pub struct SnapshotBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SnapshotBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(Snapshot::VT_ID, id);
        }
        #[inline]
        pub fn add_parent_id(&mut self, parent_id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(Snapshot::VT_PARENT_ID, parent_id);
        }
        #[inline]
        pub fn add_nodes(
            &mut self,
            nodes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<NodeSnapshot<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Snapshot::VT_NODES, nodes);
        }
        #[inline]
        pub fn add_flushed_at(&mut self, flushed_at: u64) {
            self.fbb_.push_slot::<u64>(Snapshot::VT_FLUSHED_AT, flushed_at, 0);
        }
        #[inline]
        pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Snapshot::VT_MESSAGE,
                message,
            );
        }
        #[inline]
        pub fn add_metadata(
            &mut self,
            metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MetadataItem<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Snapshot::VT_METADATA,
                metadata,
            );
        }
        #[inline]
        pub fn add_manifest_files(
            &mut self,
            manifest_files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, ManifestFileInfo>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Snapshot::VT_MANIFEST_FILES,
                manifest_files,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SnapshotBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SnapshotBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Snapshot<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Snapshot::VT_ID, "id");
            self.fbb_.required(o, Snapshot::VT_NODES, "nodes");
            self.fbb_.required(o, Snapshot::VT_MESSAGE, "message");
            self.fbb_.required(o, Snapshot::VT_METADATA, "metadata");
            self.fbb_.required(o, Snapshot::VT_MANIFEST_FILES, "manifest_files");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Snapshot<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Snapshot");
            ds.field("id", &self.id());
            ds.field("parent_id", &self.parent_id());
            ds.field("nodes", &self.nodes());
            ds.field("flushed_at", &self.flushed_at());
            ds.field("message", &self.message());
            ds.field("metadata", &self.metadata());
            ds.field("manifest_files", &self.manifest_files());
            ds.finish()
        }
    }
    pub enum ChunkIndicesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ChunkIndices<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ChunkIndices<'a> {
        type Inner = ChunkIndices<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ChunkIndices<'a> {
        pub const VT_COORDS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ChunkIndices { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ChunkIndicesArgs<'args>,
        ) -> flatbuffers::WIPOffset<ChunkIndices<'bldr>> {
            let mut builder = ChunkIndicesBuilder::new(_fbb);
            if let Some(x) = args.coords {
                builder.add_coords(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn coords(&self) -> flatbuffers::Vector<'a, u32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                        ChunkIndices::VT_COORDS,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ChunkIndices<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("coords", Self::VT_COORDS, true)?
     .finish();
            Ok(())
        }
    }
    pub struct ChunkIndicesArgs<'a> {
        pub coords: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    }
    impl<'a> Default for ChunkIndicesArgs<'a> {
        #[inline]
        fn default() -> Self {
            ChunkIndicesArgs {
      coords: None, // required field
    }
        }
    }

    pub struct ChunkIndicesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ChunkIndicesBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_coords(
            &mut self,
            coords: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ChunkIndices::VT_COORDS,
                coords,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ChunkIndicesBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ChunkIndicesBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ChunkIndices<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ChunkIndices::VT_COORDS, "coords");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ChunkIndices<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ChunkIndices");
            ds.field("coords", &self.coords());
            ds.finish()
        }
    }
    pub enum ArrayUpdatedChunksOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArrayUpdatedChunks<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayUpdatedChunks<'a> {
        type Inner = ArrayUpdatedChunks<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ArrayUpdatedChunks<'a> {
        pub const VT_NODE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_CHUNKS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayUpdatedChunks { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ArrayUpdatedChunksArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayUpdatedChunks<'bldr>> {
            let mut builder = ArrayUpdatedChunksBuilder::new(_fbb);
            if let Some(x) = args.chunks {
                builder.add_chunks(x);
            }
            if let Some(x) = args.node_id {
                builder.add_node_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn node_id(&self) -> &'a ObjectId8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<ObjectId8>(ArrayUpdatedChunks::VT_NODE_ID, None).unwrap()
            }
        }
        #[inline]
        pub fn chunks(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkIndices<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<ChunkIndices>,
                        >,
                    >>(ArrayUpdatedChunks::VT_CHUNKS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ArrayUpdatedChunks<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ObjectId8>("node_id", Self::VT_NODE_ID, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ChunkIndices>>,
                >>("chunks", Self::VT_CHUNKS, true)?
                .finish();
            Ok(())
        }
    }
    pub struct ArrayUpdatedChunksArgs<'a> {
        pub node_id: Option<&'a ObjectId8>,
        pub chunks: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkIndices<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ArrayUpdatedChunksArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayUpdatedChunksArgs {
                node_id: None, // required field
                chunks: None,  // required field
            }
        }
    }

    pub struct ArrayUpdatedChunksBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArrayUpdatedChunksBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_node_id(&mut self, node_id: &ObjectId8) {
            self.fbb_
                .push_slot_always::<&ObjectId8>(ArrayUpdatedChunks::VT_NODE_ID, node_id);
        }
        #[inline]
        pub fn add_chunks(
            &mut self,
            chunks: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ChunkIndices<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayUpdatedChunks::VT_CHUNKS,
                chunks,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ArrayUpdatedChunksBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ArrayUpdatedChunksBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayUpdatedChunks<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ArrayUpdatedChunks::VT_NODE_ID, "node_id");
            self.fbb_.required(o, ArrayUpdatedChunks::VT_CHUNKS, "chunks");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ArrayUpdatedChunks<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ArrayUpdatedChunks");
            ds.field("node_id", &self.node_id());
            ds.field("chunks", &self.chunks());
            ds.finish()
        }
    }
    pub enum MoveOperationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MoveOperation<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MoveOperation<'a> {
        type Inner = MoveOperation<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> MoveOperation<'a> {
        pub const VT_FROM: flatbuffers::VOffsetT = 4;
        pub const VT_TO: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MoveOperation { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MoveOperationArgs<'args>,
        ) -> flatbuffers::WIPOffset<MoveOperation<'bldr>> {
            let mut builder = MoveOperationBuilder::new(_fbb);
            if let Some(x) = args.to {
                builder.add_to(x);
            }
            if let Some(x) = args.from {
                builder.add_from(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn from(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        MoveOperation::VT_FROM,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn to(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(MoveOperation::VT_TO, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for MoveOperation<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "from",
                    Self::VT_FROM,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "to",
                    Self::VT_TO,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MoveOperationArgs<'a> {
        pub from: Option<flatbuffers::WIPOffset<&'a str>>,
        pub to: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for MoveOperationArgs<'a> {
        #[inline]
        fn default() -> Self {
            MoveOperationArgs {
                from: None, // required field
                to: None,   // required field
            }
        }
    }

    pub struct MoveOperationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MoveOperationBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_from(&mut self, from: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MoveOperation::VT_FROM,
                from,
            );
        }
        #[inline]
        pub fn add_to(&mut self, to: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MoveOperation::VT_TO, to);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MoveOperationBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MoveOperationBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MoveOperation<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, MoveOperation::VT_FROM, "from");
            self.fbb_.required(o, MoveOperation::VT_TO, "to");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MoveOperation<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MoveOperation");
            ds.field("from", &self.from());
            ds.field("to", &self.to());
            ds.finish()
        }
    }
    pub enum TransactionLogOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionLog<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionLog<'a> {
        type Inner = TransactionLog<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> TransactionLog<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_NEW_GROUPS: flatbuffers::VOffsetT = 6;
        pub const VT_NEW_ARRAYS: flatbuffers::VOffsetT = 8;
        pub const VT_DELETED_GROUPS: flatbuffers::VOffsetT = 10;
        pub const VT_DELETED_ARRAYS: flatbuffers::VOffsetT = 12;
        pub const VT_UPDATED_ARRAYS: flatbuffers::VOffsetT = 14;
        pub const VT_UPDATED_GROUPS: flatbuffers::VOffsetT = 16;
        pub const VT_UPDATED_CHUNKS: flatbuffers::VOffsetT = 18;
        pub const VT_MOVED_NODES: flatbuffers::VOffsetT = 20;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionLog { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionLogArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionLog<'bldr>> {
            let mut builder = TransactionLogBuilder::new(_fbb);
            if let Some(x) = args.moved_nodes {
                builder.add_moved_nodes(x);
            }
            if let Some(x) = args.updated_chunks {
                builder.add_updated_chunks(x);
            }
            if let Some(x) = args.updated_groups {
                builder.add_updated_groups(x);
            }
            if let Some(x) = args.updated_arrays {
                builder.add_updated_arrays(x);
            }
            if let Some(x) = args.deleted_arrays {
                builder.add_deleted_arrays(x);
            }
            if let Some(x) = args.deleted_groups {
                builder.add_deleted_groups(x);
            }
            if let Some(x) = args.new_arrays {
                builder.add_new_arrays(x);
            }
            if let Some(x) = args.new_groups {
                builder.add_new_groups(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(TransactionLog::VT_ID, None).unwrap() }
        }
        #[inline]
        pub fn new_groups(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_NEW_GROUPS, None).unwrap()
            }
        }
        #[inline]
        pub fn new_arrays(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_NEW_ARRAYS, None).unwrap()
            }
        }
        #[inline]
        pub fn deleted_groups(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_DELETED_GROUPS, None).unwrap()
            }
        }
        #[inline]
        pub fn deleted_arrays(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_DELETED_ARRAYS, None).unwrap()
            }
        }
        #[inline]
        pub fn updated_arrays(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_UPDATED_ARRAYS, None).unwrap()
            }
        }
        #[inline]
        pub fn updated_groups(&self) -> flatbuffers::Vector<'a, ObjectId8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ObjectId8>>>(TransactionLog::VT_UPDATED_GROUPS, None).unwrap()
            }
        }
        #[inline]
        pub fn updated_chunks(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayUpdatedChunks<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<ArrayUpdatedChunks>,
                        >,
                    >>(TransactionLog::VT_UPDATED_CHUNKS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn moved_nodes(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MoveOperation<'a>>>,
        > {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MoveOperation>>,
                >>(TransactionLog::VT_MOVED_NODES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionLog<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<ObjectId12>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("new_groups", Self::VT_NEW_GROUPS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("new_arrays", Self::VT_NEW_ARRAYS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("deleted_groups", Self::VT_DELETED_GROUPS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("deleted_arrays", Self::VT_DELETED_ARRAYS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("updated_arrays", Self::VT_UPDATED_ARRAYS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ObjectId8>>>("updated_groups", Self::VT_UPDATED_GROUPS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ArrayUpdatedChunks>>>>("updated_chunks", Self::VT_UPDATED_CHUNKS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MoveOperation>>>>("moved_nodes", Self::VT_MOVED_NODES, false)?
     .finish();
            Ok(())
        }
    }
    pub struct TransactionLogArgs<'a> {
        pub id: Option<&'a ObjectId12>,
        pub new_groups:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub new_arrays:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub deleted_groups:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub deleted_arrays:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub updated_arrays:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub updated_groups:
            Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ObjectId8>>>,
        pub updated_chunks: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<ArrayUpdatedChunks<'a>>,
                >,
            >,
        >,
        pub moved_nodes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MoveOperation<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TransactionLogArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionLogArgs {
                id: None,             // required field
                new_groups: None,     // required field
                new_arrays: None,     // required field
                deleted_groups: None, // required field
                deleted_arrays: None, // required field
                updated_arrays: None, // required field
                updated_groups: None, // required field
                updated_chunks: None, // required field
                moved_nodes: None,
            }
        }
    }

    pub struct TransactionLogBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionLogBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(TransactionLog::VT_ID, id);
        }
        #[inline]
        pub fn add_new_groups(
            &mut self,
            new_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_NEW_GROUPS,
                new_groups,
            );
        }
        #[inline]
        pub fn add_new_arrays(
            &mut self,
            new_arrays: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_NEW_ARRAYS,
                new_arrays,
            );
        }
        #[inline]
        pub fn add_deleted_groups(
            &mut self,
            deleted_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_DELETED_GROUPS,
                deleted_groups,
            );
        }
        #[inline]
        pub fn add_deleted_arrays(
            &mut self,
            deleted_arrays: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_DELETED_ARRAYS,
                deleted_arrays,
            );
        }
        #[inline]
        pub fn add_updated_arrays(
            &mut self,
            updated_arrays: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_UPDATED_ARRAYS,
                updated_arrays,
            );
        }
        #[inline]
        pub fn add_updated_groups(
            &mut self,
            updated_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ObjectId8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_UPDATED_GROUPS,
                updated_groups,
            );
        }
        #[inline]
        pub fn add_updated_chunks(
            &mut self,
            updated_chunks: flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'b,
                    flatbuffers::ForwardsUOffset<ArrayUpdatedChunks<'b>>,
                >,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_UPDATED_CHUNKS,
                updated_chunks,
            );
        }
        #[inline]
        pub fn add_moved_nodes(
            &mut self,
            moved_nodes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MoveOperation<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionLog::VT_MOVED_NODES,
                moved_nodes,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionLogBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionLogBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionLog<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, TransactionLog::VT_ID, "id");
            self.fbb_.required(o, TransactionLog::VT_NEW_GROUPS, "new_groups");
            self.fbb_.required(o, TransactionLog::VT_NEW_ARRAYS, "new_arrays");
            self.fbb_.required(o, TransactionLog::VT_DELETED_GROUPS, "deleted_groups");
            self.fbb_.required(o, TransactionLog::VT_DELETED_ARRAYS, "deleted_arrays");
            self.fbb_.required(o, TransactionLog::VT_UPDATED_ARRAYS, "updated_arrays");
            self.fbb_.required(o, TransactionLog::VT_UPDATED_GROUPS, "updated_groups");
            self.fbb_.required(o, TransactionLog::VT_UPDATED_CHUNKS, "updated_chunks");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionLog<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionLog");
            ds.field("id", &self.id());
            ds.field("new_groups", &self.new_groups());
            ds.field("new_arrays", &self.new_arrays());
            ds.field("deleted_groups", &self.deleted_groups());
            ds.field("deleted_arrays", &self.deleted_arrays());
            ds.field("updated_arrays", &self.updated_arrays());
            ds.field("updated_groups", &self.updated_groups());
            ds.field("updated_chunks", &self.updated_chunks());
            ds.field("moved_nodes", &self.moved_nodes());
            ds.finish()
        }
    }
    pub enum RefOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Ref<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Ref<'a> {
        type Inner = Ref<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> Ref<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_SNAPSHOT_INDEX: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Ref { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RefArgs<'args>,
        ) -> flatbuffers::WIPOffset<Ref<'bldr>> {
            let mut builder = RefBuilder::new(_fbb);
            builder.add_snapshot_index(args.snapshot_index);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Ref::VT_NAME, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn snapshot_index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Ref::VT_SNAPSHOT_INDEX, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Ref<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    true,
                )?
                .visit_field::<u32>("snapshot_index", Self::VT_SNAPSHOT_INDEX, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RefArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub snapshot_index: u32,
    }
    impl<'a> Default for RefArgs<'a> {
        #[inline]
        fn default() -> Self {
            RefArgs {
                name: None, // required field
                snapshot_index: 0,
            }
        }
    }

    pub struct RefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RefBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ref::VT_NAME, name);
        }
        #[inline]
        pub fn add_snapshot_index(&mut self, snapshot_index: u32) {
            self.fbb_.push_slot::<u32>(Ref::VT_SNAPSHOT_INDEX, snapshot_index, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RefBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RefBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Ref<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Ref::VT_NAME, "name");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Ref<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Ref");
            ds.field("name", &self.name());
            ds.field("snapshot_index", &self.snapshot_index());
            ds.finish()
        }
    }
    pub enum SnapshotInfoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SnapshotInfo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SnapshotInfo<'a> {
        type Inner = SnapshotInfo<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> SnapshotInfo<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_PARENT_OFFSET: flatbuffers::VOffsetT = 6;
        pub const VT_FLUSHED_AT: flatbuffers::VOffsetT = 8;
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 10;
        pub const VT_METADATA: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SnapshotInfo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SnapshotInfoArgs<'args>,
        ) -> flatbuffers::WIPOffset<SnapshotInfo<'bldr>> {
            let mut builder = SnapshotInfoBuilder::new(_fbb);
            builder.add_flushed_at(args.flushed_at);
            if let Some(x) = args.metadata {
                builder.add_metadata(x);
            }
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            builder.add_parent_offset(args.parent_offset);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<ObjectId12>(SnapshotInfo::VT_ID, None).unwrap() }
        }
        #[inline]
        pub fn parent_offset(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<i32>(SnapshotInfo::VT_PARENT_OFFSET, Some(0)).unwrap()
            }
        }
        #[inline]
        pub fn flushed_at(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(SnapshotInfo::VT_FLUSHED_AT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn message(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        SnapshotInfo::VT_MESSAGE,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn metadata(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem>>,
                >>(SnapshotInfo::VT_METADATA, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SnapshotInfo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ObjectId12>("id", Self::VT_ID, true)?
                .visit_field::<i32>("parent_offset", Self::VT_PARENT_OFFSET, false)?
                .visit_field::<u64>("flushed_at", Self::VT_FLUSHED_AT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "message",
                    Self::VT_MESSAGE,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MetadataItem>>,
                >>("metadata", Self::VT_METADATA, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SnapshotInfoArgs<'a> {
        pub id: Option<&'a ObjectId12>,
        pub parent_offset: i32,
        pub flushed_at: u64,
        pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        pub metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SnapshotInfoArgs<'a> {
        #[inline]
        fn default() -> Self {
            SnapshotInfoArgs {
                id: None, // required field
                parent_offset: 0,
                flushed_at: 0,
                message: None, // required field
                metadata: None,
            }
        }
    }

    pub struct SnapshotInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SnapshotInfoBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(SnapshotInfo::VT_ID, id);
        }
        #[inline]
        pub fn add_parent_offset(&mut self, parent_offset: i32) {
            self.fbb_.push_slot::<i32>(SnapshotInfo::VT_PARENT_OFFSET, parent_offset, 0);
        }
        #[inline]
        pub fn add_flushed_at(&mut self, flushed_at: u64) {
            self.fbb_.push_slot::<u64>(SnapshotInfo::VT_FLUSHED_AT, flushed_at, 0);
        }
        #[inline]
        pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SnapshotInfo::VT_MESSAGE,
                message,
            );
        }
        #[inline]
        pub fn add_metadata(
            &mut self,
            metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MetadataItem<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SnapshotInfo::VT_METADATA,
                metadata,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SnapshotInfoBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SnapshotInfoBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SnapshotInfo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, SnapshotInfo::VT_ID, "id");
            self.fbb_.required(o, SnapshotInfo::VT_MESSAGE, "message");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SnapshotInfo<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SnapshotInfo");
            ds.field("id", &self.id());
            ds.field("parent_offset", &self.parent_offset());
            ds.field("flushed_at", &self.flushed_at());
            ds.field("message", &self.message());
            ds.field("metadata", &self.metadata());
            ds.finish()
        }
    }
    pub enum RepoStatusOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RepoStatus<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RepoStatus<'a> {
        type Inner = RepoStatus<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> RepoStatus<'a> {
        pub const VT_AVAILABILITY: flatbuffers::VOffsetT = 4;
        pub const VT_SET_AT: flatbuffers::VOffsetT = 6;
        pub const VT_LIMITED_AVAILABILITY_REASON: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RepoStatus { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RepoStatusArgs<'args>,
        ) -> flatbuffers::WIPOffset<RepoStatus<'bldr>> {
            let mut builder = RepoStatusBuilder::new(_fbb);
            builder.add_set_at(args.set_at);
            if let Some(x) = args.limited_availability_reason {
                builder.add_limited_availability_reason(x);
            }
            builder.add_availability(args.availability);
            builder.finish()
        }

        #[inline]
        pub fn availability(&self) -> RepoAvailability {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RepoAvailability>(
                        RepoStatus::VT_AVAILABILITY,
                        Some(RepoAvailability::Online),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn set_at(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(RepoStatus::VT_SET_AT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn limited_availability_reason(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    RepoStatus::VT_LIMITED_AVAILABILITY_REASON,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for RepoStatus<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<RepoAvailability>(
                    "availability",
                    Self::VT_AVAILABILITY,
                    false,
                )?
                .visit_field::<u64>("set_at", Self::VT_SET_AT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "limited_availability_reason",
                    Self::VT_LIMITED_AVAILABILITY_REASON,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct RepoStatusArgs<'a> {
        pub availability: RepoAvailability,
        pub set_at: u64,
        pub limited_availability_reason: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for RepoStatusArgs<'a> {
        #[inline]
        fn default() -> Self {
            RepoStatusArgs {
                availability: RepoAvailability::Online,
                set_at: 0,
                limited_availability_reason: None,
            }
        }
    }

    pub struct RepoStatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RepoStatusBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_availability(&mut self, availability: RepoAvailability) {
            self.fbb_.push_slot::<RepoAvailability>(
                RepoStatus::VT_AVAILABILITY,
                availability,
                RepoAvailability::Online,
            );
        }
        #[inline]
        pub fn add_set_at(&mut self, set_at: u64) {
            self.fbb_.push_slot::<u64>(RepoStatus::VT_SET_AT, set_at, 0);
        }
        #[inline]
        pub fn add_limited_availability_reason(
            &mut self,
            limited_availability_reason: flatbuffers::WIPOffset<&'b str>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RepoStatus::VT_LIMITED_AVAILABILITY_REASON,
                limited_availability_reason,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RepoStatusBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RepoStatusBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RepoStatus<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RepoStatus<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RepoStatus");
            ds.field("availability", &self.availability());
            ds.field("set_at", &self.set_at());
            ds.field("limited_availability_reason", &self.limited_availability_reason());
            ds.finish()
        }
    }
    pub enum RepoInitializedUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RepoInitializedUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RepoInitializedUpdate<'a> {
        type Inner = RepoInitializedUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> RepoInitializedUpdate<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RepoInitializedUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            _args: &'args RepoInitializedUpdateArgs,
        ) -> flatbuffers::WIPOffset<RepoInitializedUpdate<'bldr>> {
            let mut builder = RepoInitializedUpdateBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for RepoInitializedUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct RepoInitializedUpdateArgs {}
    impl<'a> Default for RepoInitializedUpdateArgs {
        #[inline]
        fn default() -> Self {
            RepoInitializedUpdateArgs {}
        }
    }

    pub struct RepoInitializedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RepoInitializedUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RepoInitializedUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RepoInitializedUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RepoInitializedUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RepoInitializedUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RepoInitializedUpdate");
            ds.finish()
        }
    }
    pub enum RepoMigratedUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RepoMigratedUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RepoMigratedUpdate<'a> {
        type Inner = RepoMigratedUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> RepoMigratedUpdate<'a> {
        pub const VT_FROM_VERSION: flatbuffers::VOffsetT = 4;
        pub const VT_TO_VERSION: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RepoMigratedUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RepoMigratedUpdateArgs,
        ) -> flatbuffers::WIPOffset<RepoMigratedUpdate<'bldr>> {
            let mut builder = RepoMigratedUpdateBuilder::new(_fbb);
            builder.add_to_version(args.to_version);
            builder.add_from_version(args.from_version);
            builder.finish()
        }

        #[inline]
        pub fn from_version(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<u8>(RepoMigratedUpdate::VT_FROM_VERSION, Some(0)).unwrap()
            }
        }
        #[inline]
        pub fn to_version(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<u8>(RepoMigratedUpdate::VT_TO_VERSION, Some(0)).unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for RepoMigratedUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("from_version", Self::VT_FROM_VERSION, false)?
                .visit_field::<u8>("to_version", Self::VT_TO_VERSION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RepoMigratedUpdateArgs {
        pub from_version: u8,
        pub to_version: u8,
    }
    impl<'a> Default for RepoMigratedUpdateArgs {
        #[inline]
        fn default() -> Self {
            RepoMigratedUpdateArgs { from_version: 0, to_version: 0 }
        }
    }

    pub struct RepoMigratedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RepoMigratedUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_from_version(&mut self, from_version: u8) {
            self.fbb_.push_slot::<u8>(
                RepoMigratedUpdate::VT_FROM_VERSION,
                from_version,
                0,
            );
        }
        #[inline]
        pub fn add_to_version(&mut self, to_version: u8) {
            self.fbb_.push_slot::<u8>(RepoMigratedUpdate::VT_TO_VERSION, to_version, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RepoMigratedUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RepoMigratedUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RepoMigratedUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RepoMigratedUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RepoMigratedUpdate");
            ds.field("from_version", &self.from_version());
            ds.field("to_version", &self.to_version());
            ds.finish()
        }
    }
    pub enum ConfigChangedUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ConfigChangedUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ConfigChangedUpdate<'a> {
        type Inner = ConfigChangedUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ConfigChangedUpdate<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ConfigChangedUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            _args: &'args ConfigChangedUpdateArgs,
        ) -> flatbuffers::WIPOffset<ConfigChangedUpdate<'bldr>> {
            let mut builder = ConfigChangedUpdateBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for ConfigChangedUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct ConfigChangedUpdateArgs {}
    impl<'a> Default for ConfigChangedUpdateArgs {
        #[inline]
        fn default() -> Self {
            ConfigChangedUpdateArgs {}
        }
    }

    pub struct ConfigChangedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConfigChangedUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ConfigChangedUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ConfigChangedUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ConfigChangedUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ConfigChangedUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ConfigChangedUpdate");
            ds.finish()
        }
    }
    pub enum TagCreatedUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TagCreatedUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TagCreatedUpdate<'a> {
        type Inner = TagCreatedUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> TagCreatedUpdate<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TagCreatedUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TagCreatedUpdateArgs<'args>,
        ) -> flatbuffers::WIPOffset<TagCreatedUpdate<'bldr>> {
            let mut builder = TagCreatedUpdateBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        TagCreatedUpdate::VT_NAME,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TagCreatedUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TagCreatedUpdateArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TagCreatedUpdateArgs<'a> {
        #[inline]
        fn default() -> Self {
            TagCreatedUpdateArgs {
      name: None, // required field
    }
        }
    }

    pub struct TagCreatedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TagCreatedUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TagCreatedUpdate::VT_NAME,
                name,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TagCreatedUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TagCreatedUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TagCreatedUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, TagCreatedUpdate::VT_NAME, "name");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TagCreatedUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TagCreatedUpdate");
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum TagDeletedUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TagDeletedUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TagDeletedUpdate<'a> {
        type Inner = TagDeletedUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> TagDeletedUpdate<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_PREVIOUS_SNAP_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TagDeletedUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TagDeletedUpdateArgs<'args>,
        ) -> flatbuffers::WIPOffset<TagDeletedUpdate<'bldr>> {
            let mut builder = TagDeletedUpdateBuilder::new(_fbb);
            if let Some(x) = args.previous_snap_id {
                builder.add_previous_snap_id(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        TagDeletedUpdate::VT_NAME,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn previous_snap_id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ObjectId12>(TagDeletedUpdate::VT_PREVIOUS_SNAP_ID, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TagDeletedUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    true,
                )?
                .visit_field::<ObjectId12>(
                    "previous_snap_id",
                    Self::VT_PREVIOUS_SNAP_ID,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TagDeletedUpdateArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub previous_snap_id: Option<&'a ObjectId12>,
    }
    impl<'a> Default for TagDeletedUpdateArgs<'a> {
        #[inline]
        fn default() -> Self {
            TagDeletedUpdateArgs {
                name: None,             // required field
                previous_snap_id: None, // required field
            }
        }
    }

    pub struct TagDeletedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TagDeletedUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TagDeletedUpdate::VT_NAME,
                name,
            );
        }
        #[inline]
        pub fn add_previous_snap_id(&mut self, previous_snap_id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(
                TagDeletedUpdate::VT_PREVIOUS_SNAP_ID,
                previous_snap_id,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TagDeletedUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TagDeletedUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TagDeletedUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, TagDeletedUpdate::VT_NAME, "name");
            self.fbb_.required(
                o,
                TagDeletedUpdate::VT_PREVIOUS_SNAP_ID,
                "previous_snap_id",
            );
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TagDeletedUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TagDeletedUpdate");
            ds.field("name", &self.name());
            ds.field("previous_snap_id", &self.previous_snap_id());
            ds.finish()
        }
    }
    pub enum BranchCreatedUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BranchCreatedUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BranchCreatedUpdate<'a> {
        type Inner = BranchCreatedUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> BranchCreatedUpdate<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BranchCreatedUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BranchCreatedUpdateArgs<'args>,
        ) -> flatbuffers::WIPOffset<BranchCreatedUpdate<'bldr>> {
            let mut builder = BranchCreatedUpdateBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        BranchCreatedUpdate::VT_NAME,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for BranchCreatedUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BranchCreatedUpdateArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for BranchCreatedUpdateArgs<'a> {
        #[inline]
        fn default() -> Self {
            BranchCreatedUpdateArgs {
      name: None, // required field
    }
        }
    }

    pub struct BranchCreatedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BranchCreatedUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BranchCreatedUpdate::VT_NAME,
                name,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BranchCreatedUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BranchCreatedUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BranchCreatedUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, BranchCreatedUpdate::VT_NAME, "name");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BranchCreatedUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BranchCreatedUpdate");
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum BranchDeletedUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BranchDeletedUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BranchDeletedUpdate<'a> {
        type Inner = BranchDeletedUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> BranchDeletedUpdate<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_PREVIOUS_SNAP_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BranchDeletedUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BranchDeletedUpdateArgs<'args>,
        ) -> flatbuffers::WIPOffset<BranchDeletedUpdate<'bldr>> {
            let mut builder = BranchDeletedUpdateBuilder::new(_fbb);
            if let Some(x) = args.previous_snap_id {
                builder.add_previous_snap_id(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        BranchDeletedUpdate::VT_NAME,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn previous_snap_id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ObjectId12>(BranchDeletedUpdate::VT_PREVIOUS_SNAP_ID, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for BranchDeletedUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    true,
                )?
                .visit_field::<ObjectId12>(
                    "previous_snap_id",
                    Self::VT_PREVIOUS_SNAP_ID,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BranchDeletedUpdateArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub previous_snap_id: Option<&'a ObjectId12>,
    }
    impl<'a> Default for BranchDeletedUpdateArgs<'a> {
        #[inline]
        fn default() -> Self {
            BranchDeletedUpdateArgs {
                name: None,             // required field
                previous_snap_id: None, // required field
            }
        }
    }

    pub struct BranchDeletedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BranchDeletedUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BranchDeletedUpdate::VT_NAME,
                name,
            );
        }
        #[inline]
        pub fn add_previous_snap_id(&mut self, previous_snap_id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(
                BranchDeletedUpdate::VT_PREVIOUS_SNAP_ID,
                previous_snap_id,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BranchDeletedUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BranchDeletedUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BranchDeletedUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, BranchDeletedUpdate::VT_NAME, "name");
            self.fbb_.required(
                o,
                BranchDeletedUpdate::VT_PREVIOUS_SNAP_ID,
                "previous_snap_id",
            );
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BranchDeletedUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BranchDeletedUpdate");
            ds.field("name", &self.name());
            ds.field("previous_snap_id", &self.previous_snap_id());
            ds.finish()
        }
    }
    pub enum BranchResetUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BranchResetUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BranchResetUpdate<'a> {
        type Inner = BranchResetUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> BranchResetUpdate<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_PREVIOUS_SNAP_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BranchResetUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BranchResetUpdateArgs<'args>,
        ) -> flatbuffers::WIPOffset<BranchResetUpdate<'bldr>> {
            let mut builder = BranchResetUpdateBuilder::new(_fbb);
            if let Some(x) = args.previous_snap_id {
                builder.add_previous_snap_id(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        BranchResetUpdate::VT_NAME,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn previous_snap_id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ObjectId12>(BranchResetUpdate::VT_PREVIOUS_SNAP_ID, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for BranchResetUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "name",
                    Self::VT_NAME,
                    true,
                )?
                .visit_field::<ObjectId12>(
                    "previous_snap_id",
                    Self::VT_PREVIOUS_SNAP_ID,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BranchResetUpdateArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub previous_snap_id: Option<&'a ObjectId12>,
    }
    impl<'a> Default for BranchResetUpdateArgs<'a> {
        #[inline]
        fn default() -> Self {
            BranchResetUpdateArgs {
                name: None,             // required field
                previous_snap_id: None, // required field
            }
        }
    }

    pub struct BranchResetUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BranchResetUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BranchResetUpdate::VT_NAME,
                name,
            );
        }
        #[inline]
        pub fn add_previous_snap_id(&mut self, previous_snap_id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(
                BranchResetUpdate::VT_PREVIOUS_SNAP_ID,
                previous_snap_id,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BranchResetUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BranchResetUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BranchResetUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, BranchResetUpdate::VT_NAME, "name");
            self.fbb_.required(
                o,
                BranchResetUpdate::VT_PREVIOUS_SNAP_ID,
                "previous_snap_id",
            );
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BranchResetUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BranchResetUpdate");
            ds.field("name", &self.name());
            ds.field("previous_snap_id", &self.previous_snap_id());
            ds.finish()
        }
    }
    pub enum NewCommitUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NewCommitUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NewCommitUpdate<'a> {
        type Inner = NewCommitUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> NewCommitUpdate<'a> {
        pub const VT_BRANCH: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NewCommitUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NewCommitUpdateArgs<'args>,
        ) -> flatbuffers::WIPOffset<NewCommitUpdate<'bldr>> {
            let mut builder = NewCommitUpdateBuilder::new(_fbb);
            if let Some(x) = args.branch {
                builder.add_branch(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn branch(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        NewCommitUpdate::VT_BRANCH,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for NewCommitUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "branch",
                    Self::VT_BRANCH,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct NewCommitUpdateArgs<'a> {
        pub branch: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for NewCommitUpdateArgs<'a> {
        #[inline]
        fn default() -> Self {
            NewCommitUpdateArgs {
      branch: None, // required field
    }
        }
    }

    pub struct NewCommitUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NewCommitUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_branch(&mut self, branch: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NewCommitUpdate::VT_BRANCH,
                branch,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NewCommitUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NewCommitUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NewCommitUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, NewCommitUpdate::VT_BRANCH, "branch");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NewCommitUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NewCommitUpdate");
            ds.field("branch", &self.branch());
            ds.finish()
        }
    }
    pub enum CommitAmendedUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CommitAmendedUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CommitAmendedUpdate<'a> {
        type Inner = CommitAmendedUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> CommitAmendedUpdate<'a> {
        pub const VT_BRANCH: flatbuffers::VOffsetT = 4;
        pub const VT_PREVIOUS_SNAP_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CommitAmendedUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args CommitAmendedUpdateArgs<'args>,
        ) -> flatbuffers::WIPOffset<CommitAmendedUpdate<'bldr>> {
            let mut builder = CommitAmendedUpdateBuilder::new(_fbb);
            if let Some(x) = args.previous_snap_id {
                builder.add_previous_snap_id(x);
            }
            if let Some(x) = args.branch {
                builder.add_branch(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn branch(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        CommitAmendedUpdate::VT_BRANCH,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn previous_snap_id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ObjectId12>(CommitAmendedUpdate::VT_PREVIOUS_SNAP_ID, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CommitAmendedUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "branch",
                    Self::VT_BRANCH,
                    true,
                )?
                .visit_field::<ObjectId12>(
                    "previous_snap_id",
                    Self::VT_PREVIOUS_SNAP_ID,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct CommitAmendedUpdateArgs<'a> {
        pub branch: Option<flatbuffers::WIPOffset<&'a str>>,
        pub previous_snap_id: Option<&'a ObjectId12>,
    }
    impl<'a> Default for CommitAmendedUpdateArgs<'a> {
        #[inline]
        fn default() -> Self {
            CommitAmendedUpdateArgs {
                branch: None,           // required field
                previous_snap_id: None, // required field
            }
        }
    }

    pub struct CommitAmendedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CommitAmendedUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_branch(&mut self, branch: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                CommitAmendedUpdate::VT_BRANCH,
                branch,
            );
        }
        #[inline]
        pub fn add_previous_snap_id(&mut self, previous_snap_id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(
                CommitAmendedUpdate::VT_PREVIOUS_SNAP_ID,
                previous_snap_id,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> CommitAmendedUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            CommitAmendedUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CommitAmendedUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, CommitAmendedUpdate::VT_BRANCH, "branch");
            self.fbb_.required(
                o,
                CommitAmendedUpdate::VT_PREVIOUS_SNAP_ID,
                "previous_snap_id",
            );
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CommitAmendedUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CommitAmendedUpdate");
            ds.field("branch", &self.branch());
            ds.field("previous_snap_id", &self.previous_snap_id());
            ds.finish()
        }
    }
    pub enum NewDetachedSnapshotUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NewDetachedSnapshotUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NewDetachedSnapshotUpdate<'a> {
        type Inner = NewDetachedSnapshotUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> NewDetachedSnapshotUpdate<'a> {
        pub const VT_NEW_SNAP_ID: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NewDetachedSnapshotUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NewDetachedSnapshotUpdateArgs<'args>,
        ) -> flatbuffers::WIPOffset<NewDetachedSnapshotUpdate<'bldr>> {
            let mut builder = NewDetachedSnapshotUpdateBuilder::new(_fbb);
            if let Some(x) = args.new_snap_id {
                builder.add_new_snap_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn new_snap_id(&self) -> &'a ObjectId12 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ObjectId12>(NewDetachedSnapshotUpdate::VT_NEW_SNAP_ID, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for NewDetachedSnapshotUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ObjectId12>("new_snap_id", Self::VT_NEW_SNAP_ID, true)?
                .finish();
            Ok(())
        }
    }
    pub struct NewDetachedSnapshotUpdateArgs<'a> {
        pub new_snap_id: Option<&'a ObjectId12>,
    }
    impl<'a> Default for NewDetachedSnapshotUpdateArgs<'a> {
        #[inline]
        fn default() -> Self {
            NewDetachedSnapshotUpdateArgs {
      new_snap_id: None, // required field
    }
        }
    }

    pub struct NewDetachedSnapshotUpdateBuilder<
        'a: 'b,
        'b,
        A: flatbuffers::Allocator + 'a,
    > {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
        NewDetachedSnapshotUpdateBuilder<'a, 'b, A>
    {
        #[inline]
        pub fn add_new_snap_id(&mut self, new_snap_id: &ObjectId12) {
            self.fbb_.push_slot_always::<&ObjectId12>(
                NewDetachedSnapshotUpdate::VT_NEW_SNAP_ID,
                new_snap_id,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NewDetachedSnapshotUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NewDetachedSnapshotUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NewDetachedSnapshotUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(
                o,
                NewDetachedSnapshotUpdate::VT_NEW_SNAP_ID,
                "new_snap_id",
            );
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NewDetachedSnapshotUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NewDetachedSnapshotUpdate");
            ds.field("new_snap_id", &self.new_snap_id());
            ds.finish()
        }
    }
    pub enum GCRanUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GCRanUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GCRanUpdate<'a> {
        type Inner = GCRanUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> GCRanUpdate<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GCRanUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            _args: &'args GCRanUpdateArgs,
        ) -> flatbuffers::WIPOffset<GCRanUpdate<'bldr>> {
            let mut builder = GCRanUpdateBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for GCRanUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct GCRanUpdateArgs {}
    impl<'a> Default for GCRanUpdateArgs {
        #[inline]
        fn default() -> Self {
            GCRanUpdateArgs {}
        }
    }

    pub struct GCRanUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GCRanUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> GCRanUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            GCRanUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GCRanUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GCRanUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GCRanUpdate");
            ds.finish()
        }
    }
    pub enum ExpirationRanUpdateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ExpirationRanUpdate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ExpirationRanUpdate<'a> {
        type Inner = ExpirationRanUpdate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> ExpirationRanUpdate<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ExpirationRanUpdate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            _args: &'args ExpirationRanUpdateArgs,
        ) -> flatbuffers::WIPOffset<ExpirationRanUpdate<'bldr>> {
            let mut builder = ExpirationRanUpdateBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for ExpirationRanUpdate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct ExpirationRanUpdateArgs {}
    impl<'a> Default for ExpirationRanUpdateArgs {
        #[inline]
        fn default() -> Self {
            ExpirationRanUpdateArgs {}
        }
    }

    pub struct ExpirationRanUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExpirationRanUpdateBuilder<'a, 'b, A> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ExpirationRanUpdateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ExpirationRanUpdateBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ExpirationRanUpdate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ExpirationRanUpdate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ExpirationRanUpdate");
            ds.finish()
        }
    }
    pub enum RepoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Repo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Repo<'a> {
        type Inner = Repo<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> Repo<'a> {
        pub const VT_SPEC_VERSION: flatbuffers::VOffsetT = 4;
        pub const VT_TAGS: flatbuffers::VOffsetT = 6;
        pub const VT_BRANCHES: flatbuffers::VOffsetT = 8;
        pub const VT_DELETED_TAGS: flatbuffers::VOffsetT = 10;
        pub const VT_SNAPSHOTS: flatbuffers::VOffsetT = 12;
        pub const VT_LAST_UPDATED_AT: flatbuffers::VOffsetT = 14;
        pub const VT_STATUS: flatbuffers::VOffsetT = 16;
        pub const VT_METADATA: flatbuffers::VOffsetT = 18;
        pub const VT_LATEST_UPDATE_TYPE: flatbuffers::VOffsetT = 20;
        pub const VT_LATEST_UPDATE: flatbuffers::VOffsetT = 22;
        pub const VT_PREVIOUS_FILE: flatbuffers::VOffsetT = 24;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Repo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RepoArgs<'args>,
        ) -> flatbuffers::WIPOffset<Repo<'bldr>> {
            let mut builder = RepoBuilder::new(_fbb);
            builder.add_last_updated_at(args.last_updated_at);
            if let Some(x) = args.previous_file {
                builder.add_previous_file(x);
            }
            if let Some(x) = args.latest_update {
                builder.add_latest_update(x);
            }
            if let Some(x) = args.metadata {
                builder.add_metadata(x);
            }
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            if let Some(x) = args.snapshots {
                builder.add_snapshots(x);
            }
            if let Some(x) = args.deleted_tags {
                builder.add_deleted_tags(x);
            }
            if let Some(x) = args.branches {
                builder.add_branches(x);
            }
            if let Some(x) = args.tags {
                builder.add_tags(x);
            }
            builder.add_latest_update_type(args.latest_update_type);
            builder.add_spec_version(args.spec_version);
            builder.finish()
        }

        #[inline]
        pub fn spec_version(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Repo::VT_SPEC_VERSION, Some(0)).unwrap() }
        }
        #[inline]
        pub fn tags(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ref<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ref>>,
                    >>(Repo::VT_TAGS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn branches(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ref<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ref>>,
                    >>(Repo::VT_BRANCHES, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn deleted_tags(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(Repo::VT_DELETED_TAGS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn snapshots(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SnapshotInfo<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<SnapshotInfo>,
                        >,
                    >>(Repo::VT_SNAPSHOTS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn last_updated_at(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Repo::VT_LAST_UPDATED_AT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn status(&self) -> RepoStatus<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<RepoStatus>>(
                        Repo::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn metadata(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem>>,
                >>(Repo::VT_METADATA, None)
            }
        }
        #[inline]
        pub fn latest_update_type(&self) -> UpdateType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<UpdateType>(
                        Repo::VT_LATEST_UPDATE_TYPE,
                        Some(UpdateType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn latest_update(&self) -> flatbuffers::Table<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        Repo::VT_LATEST_UPDATE,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn previous_file(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    Repo::VT_PREVIOUS_FILE,
                    None,
                )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_repo_initialized_update(
            &self,
        ) -> Option<RepoInitializedUpdate<'a>> {
            if self.latest_update_type() == UpdateType::RepoInitializedUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { RepoInitializedUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_repo_migrated_update(
            &self,
        ) -> Option<RepoMigratedUpdate<'a>> {
            if self.latest_update_type() == UpdateType::RepoMigratedUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { RepoMigratedUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_config_changed_update(
            &self,
        ) -> Option<ConfigChangedUpdate<'a>> {
            if self.latest_update_type() == UpdateType::ConfigChangedUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { ConfigChangedUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_tag_created_update(
            &self,
        ) -> Option<TagCreatedUpdate<'a>> {
            if self.latest_update_type() == UpdateType::TagCreatedUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { TagCreatedUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_tag_deleted_update(
            &self,
        ) -> Option<TagDeletedUpdate<'a>> {
            if self.latest_update_type() == UpdateType::TagDeletedUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { TagDeletedUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_branch_created_update(
            &self,
        ) -> Option<BranchCreatedUpdate<'a>> {
            if self.latest_update_type() == UpdateType::BranchCreatedUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { BranchCreatedUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_branch_deleted_update(
            &self,
        ) -> Option<BranchDeletedUpdate<'a>> {
            if self.latest_update_type() == UpdateType::BranchDeletedUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { BranchDeletedUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_branch_reset_update(
            &self,
        ) -> Option<BranchResetUpdate<'a>> {
            if self.latest_update_type() == UpdateType::BranchResetUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { BranchResetUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_new_commit_update(&self) -> Option<NewCommitUpdate<'a>> {
            if self.latest_update_type() == UpdateType::NewCommitUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { NewCommitUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_commit_amended_update(
            &self,
        ) -> Option<CommitAmendedUpdate<'a>> {
            if self.latest_update_type() == UpdateType::CommitAmendedUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { CommitAmendedUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_new_detached_snapshot_update(
            &self,
        ) -> Option<NewDetachedSnapshotUpdate<'a>> {
            if self.latest_update_type() == UpdateType::NewDetachedSnapshotUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { NewDetachedSnapshotUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_gcran_update(&self) -> Option<GCRanUpdate<'a>> {
            if self.latest_update_type() == UpdateType::GCRanUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { GCRanUpdate::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn latest_update_as_expiration_ran_update(
            &self,
        ) -> Option<ExpirationRanUpdate<'a>> {
            if self.latest_update_type() == UpdateType::ExpirationRanUpdate {
                let u = self.latest_update();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { ExpirationRanUpdate::init_from_table(u) })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Repo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<u8>("spec_version", Self::VT_SPEC_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Ref>>>>("tags", Self::VT_TAGS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Ref>>>>("branches", Self::VT_BRANCHES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("deleted_tags", Self::VT_DELETED_TAGS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SnapshotInfo>>>>("snapshots", Self::VT_SNAPSHOTS, true)?
     .visit_field::<u64>("last_updated_at", Self::VT_LAST_UPDATED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RepoStatus>>("status", Self::VT_STATUS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MetadataItem>>>>("metadata", Self::VT_METADATA, false)?
     .visit_union::<UpdateType, _>("latest_update_type", Self::VT_LATEST_UPDATE_TYPE, "latest_update", Self::VT_LATEST_UPDATE, true, |key, v, pos| {
        match key {
          UpdateType::RepoInitializedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RepoInitializedUpdate>>("UpdateType::RepoInitializedUpdate", pos),
          UpdateType::RepoMigratedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RepoMigratedUpdate>>("UpdateType::RepoMigratedUpdate", pos),
          UpdateType::ConfigChangedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConfigChangedUpdate>>("UpdateType::ConfigChangedUpdate", pos),
          UpdateType::TagCreatedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TagCreatedUpdate>>("UpdateType::TagCreatedUpdate", pos),
          UpdateType::TagDeletedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TagDeletedUpdate>>("UpdateType::TagDeletedUpdate", pos),
          UpdateType::BranchCreatedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BranchCreatedUpdate>>("UpdateType::BranchCreatedUpdate", pos),
          UpdateType::BranchDeletedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BranchDeletedUpdate>>("UpdateType::BranchDeletedUpdate", pos),
          UpdateType::BranchResetUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BranchResetUpdate>>("UpdateType::BranchResetUpdate", pos),
          UpdateType::NewCommitUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NewCommitUpdate>>("UpdateType::NewCommitUpdate", pos),
          UpdateType::CommitAmendedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CommitAmendedUpdate>>("UpdateType::CommitAmendedUpdate", pos),
          UpdateType::NewDetachedSnapshotUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NewDetachedSnapshotUpdate>>("UpdateType::NewDetachedSnapshotUpdate", pos),
          UpdateType::GCRanUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GCRanUpdate>>("UpdateType::GCRanUpdate", pos),
          UpdateType::ExpirationRanUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpirationRanUpdate>>("UpdateType::ExpirationRanUpdate", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("previous_file", Self::VT_PREVIOUS_FILE, false)?
     .finish();
            Ok(())
        }
    }
    pub struct RepoArgs<'a> {
        pub spec_version: u8,
        pub tags: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ref<'a>>>,
            >,
        >,
        pub branches: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ref<'a>>>,
            >,
        >,
        pub deleted_tags: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >,
        >,
        pub snapshots: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SnapshotInfo<'a>>>,
            >,
        >,
        pub last_updated_at: u64,
        pub status: Option<flatbuffers::WIPOffset<RepoStatus<'a>>>,
        pub metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataItem<'a>>>,
            >,
        >,
        pub latest_update_type: UpdateType,
        pub latest_update: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub previous_file: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for RepoArgs<'a> {
        #[inline]
        fn default() -> Self {
            RepoArgs {
                spec_version: 0,
                tags: None,         // required field
                branches: None,     // required field
                deleted_tags: None, // required field
                snapshots: None,    // required field
                last_updated_at: 0,
                status: None, // required field
                metadata: None,
                latest_update_type: UpdateType::NONE,
                latest_update: None, // required field
                previous_file: None,
            }
        }
    }

    pub struct RepoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RepoBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_spec_version(&mut self, spec_version: u8) {
            self.fbb_.push_slot::<u8>(Repo::VT_SPEC_VERSION, spec_version, 0);
        }
        #[inline]
        pub fn add_tags(
            &mut self,
            tags: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Ref<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Repo::VT_TAGS, tags);
        }
        #[inline]
        pub fn add_branches(
            &mut self,
            branches: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Ref<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Repo::VT_BRANCHES,
                branches,
            );
        }
        #[inline]
        pub fn add_deleted_tags(
            &mut self,
            deleted_tags: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Repo::VT_DELETED_TAGS,
                deleted_tags,
            );
        }
        #[inline]
        pub fn add_snapshots(
            &mut self,
            snapshots: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SnapshotInfo<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Repo::VT_SNAPSHOTS,
                snapshots,
            );
        }
        #[inline]
        pub fn add_last_updated_at(&mut self, last_updated_at: u64) {
            self.fbb_.push_slot::<u64>(Repo::VT_LAST_UPDATED_AT, last_updated_at, 0);
        }
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<RepoStatus<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RepoStatus>>(
                Repo::VT_STATUS,
                status,
            );
        }
        #[inline]
        pub fn add_metadata(
            &mut self,
            metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MetadataItem<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Repo::VT_METADATA,
                metadata,
            );
        }
        #[inline]
        pub fn add_latest_update_type(&mut self, latest_update_type: UpdateType) {
            self.fbb_.push_slot::<UpdateType>(
                Repo::VT_LATEST_UPDATE_TYPE,
                latest_update_type,
                UpdateType::NONE,
            );
        }
        #[inline]
        pub fn add_latest_update(
            &mut self,
            latest_update: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Repo::VT_LATEST_UPDATE,
                latest_update,
            );
        }
        #[inline]
        pub fn add_previous_file(
            &mut self,
            previous_file: flatbuffers::WIPOffset<&'b str>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Repo::VT_PREVIOUS_FILE,
                previous_file,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RepoBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RepoBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Repo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Repo::VT_TAGS, "tags");
            self.fbb_.required(o, Repo::VT_BRANCHES, "branches");
            self.fbb_.required(o, Repo::VT_DELETED_TAGS, "deleted_tags");
            self.fbb_.required(o, Repo::VT_SNAPSHOTS, "snapshots");
            self.fbb_.required(o, Repo::VT_STATUS, "status");
            self.fbb_.required(o, Repo::VT_LATEST_UPDATE, "latest_update");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Repo<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Repo");
            ds.field("spec_version", &self.spec_version());
            ds.field("tags", &self.tags());
            ds.field("branches", &self.branches());
            ds.field("deleted_tags", &self.deleted_tags());
            ds.field("snapshots", &self.snapshots());
            ds.field("last_updated_at", &self.last_updated_at());
            ds.field("status", &self.status());
            ds.field("metadata", &self.metadata());
            ds.field("latest_update_type", &self.latest_update_type());
            match self.latest_update_type() {
                UpdateType::RepoInitializedUpdate => {
                    if let Some(x) = self.latest_update_as_repo_initialized_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::RepoMigratedUpdate => {
                    if let Some(x) = self.latest_update_as_repo_migrated_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::ConfigChangedUpdate => {
                    if let Some(x) = self.latest_update_as_config_changed_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::TagCreatedUpdate => {
                    if let Some(x) = self.latest_update_as_tag_created_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::TagDeletedUpdate => {
                    if let Some(x) = self.latest_update_as_tag_deleted_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::BranchCreatedUpdate => {
                    if let Some(x) = self.latest_update_as_branch_created_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::BranchDeletedUpdate => {
                    if let Some(x) = self.latest_update_as_branch_deleted_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::BranchResetUpdate => {
                    if let Some(x) = self.latest_update_as_branch_reset_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::NewCommitUpdate => {
                    if let Some(x) = self.latest_update_as_new_commit_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::CommitAmendedUpdate => {
                    if let Some(x) = self.latest_update_as_commit_amended_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::NewDetachedSnapshotUpdate => {
                    if let Some(x) = self.latest_update_as_new_detached_snapshot_update()
                    {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::GCRanUpdate => {
                    if let Some(x) = self.latest_update_as_gcran_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                UpdateType::ExpirationRanUpdate => {
                    if let Some(x) = self.latest_update_as_expiration_ran_update() {
                        ds.field("latest_update", &x)
                    } else {
                        ds.field("latest_update", &"InvalidFlatbuffer: Union discriminant does not match value.")
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("latest_update", &x)
                }
            };
            ds.field("previous_file", &self.previous_file());
            ds.finish()
        }
    }
} // pub mod generated
