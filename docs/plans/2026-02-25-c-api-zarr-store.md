# C API for Icechunk Zarr Store — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create a C FFI layer (`icechunk-c`) exposing the Zarr Store interface so Julia (and other languages) can use icechunk via `ccall`.

**Architecture:** A new workspace crate `icechunk-c` wraps the Rust `Store` (and supporting types) behind `extern "C"` functions using opaque pointers. A global tokio runtime is lazily initialized; all async operations block on it internally. Errors use return codes with a thread-local error string retrieved via `icechunk_last_error()`. Listing operations use an iterator pattern (open/next/free). Returned byte buffers are `malloc`-allocated so callers can free them with standard `free()`.

**Tech Stack:** Rust (edition 2024), `libc` crate for `malloc`/`free`, `tokio` for async runtime, `cbindgen` for generating the C header file.

---

### Task 1: Create the `icechunk-c` workspace crate

**Files:**
- Create: `icechunk-c/Cargo.toml`
- Create: `icechunk-c/src/lib.rs`
- Create: `icechunk-c/cbindgen.toml`
- Modify: `Cargo.toml` (root workspace)

**Step 1: Create the crate directory**

Run: `mkdir -p icechunk-c/src`

**Step 2: Create `icechunk-c/Cargo.toml`**

```toml
[package]
name = "icechunk-c"
version = "0.1.0"
edition.workspace = true
publish = false

[lib]
crate-type = ["cdylib", "staticlib"]

[dependencies]
icechunk = { path = "../icechunk", version = "0.3.14" }
tokio = { version = "1", features = ["rt-multi-thread"] }
bytes = "1"
libc = "0.2"

[build-dependencies]
cbindgen = "0.28"

[lints]
workspace = true
```

**Step 3: Create `icechunk-c/cbindgen.toml`**

```toml
language = "C"
header = "/* Generated by cbindgen — do not edit */"
include_guard = "ICECHUNK_H"
no_includes = true
sys_includes = ["stdint.h", "stddef.h", "stdbool.h"]

[export]
prefix = "Icechunk"

[enum]
rename_variants = "ScreamingSnakeCase"
```

**Step 4: Create `icechunk-c/src/lib.rs` with a minimal placeholder**

```rust
//! C FFI bindings for the Icechunk Zarr store.

#![allow(clippy::missing_safety_doc)]
```

**Step 5: Add crate to workspace in root `Cargo.toml`**

Change the `members` line:

```toml
members = ["icechunk", "icechunk-python", "icechunk-macros", "icechunk-c"]
```

Do NOT add `icechunk-c` to `default-members` (keep default-members as `["icechunk"]`).

**Step 6: Verify it compiles**

Run: `cargo build -p icechunk-c`
Expected: Compiles with no errors.

**Step 7: Commit**

```bash
git add icechunk-c/ Cargo.toml
git commit -m "feat: scaffold icechunk-c crate for C FFI bindings"
```

---

### Task 2: Runtime and error infrastructure

**Files:**
- Create: `icechunk-c/src/error.rs`
- Create: `icechunk-c/src/runtime.rs`
- Modify: `icechunk-c/src/lib.rs`

**Step 1: Write a test for the error infrastructure**

Create `icechunk-c/src/error.rs`:

```rust
//! Thread-local error string and return codes.

use std::cell::RefCell;
use std::ffi::CString;
use std::ptr;

/// Return codes for all icechunk_* functions.
pub const ICECHUNK_SUCCESS: i32 = 0;
pub const ICECHUNK_ERROR: i32 = -1;
pub const ICECHUNK_ERROR_NOT_FOUND: i32 = -2;
pub const ICECHUNK_ERROR_READONLY: i32 = -3;
pub const ICECHUNK_ERROR_NULL_ARGUMENT: i32 = -4;

thread_local! {
    static LAST_ERROR: RefCell<Option<CString>> = const { RefCell::new(None) };
}

/// Store an error message in thread-local storage.
pub(crate) fn set_last_error(msg: String) {
    LAST_ERROR.with(|cell| {
        // Replace interior NULs so CString::new won't fail.
        let sanitized = msg.replace('\0', "\\0");
        *cell.borrow_mut() = CString::new(sanitized).ok();
    });
}

/// Clear the last error.
pub(crate) fn clear_last_error() {
    LAST_ERROR.with(|cell| {
        *cell.borrow_mut() = None;
    });
}

/// Return a pointer to the thread-local error string, or null if none.
///
/// # Safety
/// The returned pointer is valid until the next icechunk call on this thread.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_last_error() -> *const libc::c_char {
    LAST_ERROR.with(|cell| {
        let borrow = cell.borrow();
        match borrow.as_ref() {
            Some(cstr) => cstr.as_ptr(),
            None => ptr::null(),
        }
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_error_roundtrip() {
        clear_last_error();
        let ptr = unsafe { icechunk_last_error() };
        assert!(ptr.is_null());

        set_last_error("something went wrong".to_string());
        let ptr = unsafe { icechunk_last_error() };
        assert!(!ptr.is_null());
        let msg = unsafe { std::ffi::CStr::from_ptr(ptr) };
        assert_eq!(msg.to_str().unwrap(), "something went wrong");

        clear_last_error();
        let ptr = unsafe { icechunk_last_error() };
        assert!(ptr.is_null());
    }

    #[test]
    fn test_error_with_nul_byte() {
        set_last_error("bad\0byte".to_string());
        let ptr = unsafe { icechunk_last_error() };
        assert!(!ptr.is_null());
        let msg = unsafe { std::ffi::CStr::from_ptr(ptr) };
        assert_eq!(msg.to_str().unwrap(), "bad\\0byte");
    }
}
```

**Step 2: Run the error tests to verify they pass**

Run: `cargo nextest run -p icechunk-c`
Expected: 2 tests pass.

**Step 3: Create `icechunk-c/src/runtime.rs`**

```rust
//! Global tokio runtime for blocking on async operations.

use std::sync::OnceLock;
use tokio::runtime::Runtime;

static RUNTIME: OnceLock<Runtime> = OnceLock::new();

/// Get or lazily create the global tokio runtime.
pub(crate) fn get_runtime() -> &'static Runtime {
    RUNTIME.get_or_init(|| {
        Runtime::new().expect("failed to create tokio runtime")
    })
}

/// Run an async future on the global runtime, blocking the current thread.
pub(crate) fn block_on<F: std::future::Future>(future: F) -> F::Output {
    get_runtime().block_on(future)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_runtime_is_singleton() {
        let r1 = get_runtime() as *const Runtime;
        let r2 = get_runtime() as *const Runtime;
        assert_eq!(r1, r2);
    }

    #[test]
    fn test_block_on_runs_future() {
        let result = block_on(async { 42 });
        assert_eq!(result, 42);
    }
}
```

**Step 4: Wire up modules in `icechunk-c/src/lib.rs`**

```rust
//! C FFI bindings for the Icechunk Zarr store.

#![allow(clippy::missing_safety_doc)]

pub mod error;
mod runtime;
```

**Step 5: Run all tests**

Run: `cargo nextest run -p icechunk-c`
Expected: 4 tests pass.

**Step 6: Commit**

```bash
git add icechunk-c/
git commit -m "feat(icechunk-c): add error infrastructure and tokio runtime"
```

---

### Task 3: Storage constructors (opaque pointer pattern)

**Files:**
- Create: `icechunk-c/src/storage.rs`
- Modify: `icechunk-c/src/lib.rs`

**Step 1: Create `icechunk-c/src/storage.rs`**

This exposes opaque `IcechunkStorage` pointers and constructors for in-memory and local filesystem storage.

```rust
//! Opaque storage handles and constructors.

use std::ffi::CStr;
use std::sync::Arc;

use icechunk::Storage;

use crate::error::*;

/// Opaque handle to an Icechunk storage backend.
pub struct IcechunkStorage {
    pub(crate) inner: Arc<dyn Storage + Send + Sync>,
}

/// Create an in-memory storage backend.
///
/// Returns null on failure (check `icechunk_last_error()`).
#[unsafe(no_mangle)]
pub extern "C" fn icechunk_storage_new_in_memory() -> *mut IcechunkStorage {
    clear_last_error();
    match crate::runtime::block_on(icechunk::new_in_memory_storage()) {
        storage => Box::into_raw(Box::new(IcechunkStorage { inner: storage })),
    }
}

/// Create a local filesystem storage backend.
///
/// `path` must be a valid null-terminated UTF-8 string.
/// Returns null on failure.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_storage_new_local_filesystem(
    path: *const libc::c_char,
) -> *mut IcechunkStorage {
    clear_last_error();
    if path.is_null() {
        set_last_error("path must not be null".to_string());
        return std::ptr::null_mut();
    }
    let path_str = match unsafe { CStr::from_ptr(path) }.to_str() {
        Ok(s) => s,
        Err(e) => {
            set_last_error(format!("invalid UTF-8 in path: {e}"));
            return std::ptr::null_mut();
        }
    };

    match crate::runtime::block_on(async {
        icechunk::new_local_filesystem_storage(path_str).await
    }) {
        Ok(storage) => Box::into_raw(Box::new(IcechunkStorage { inner: storage })),
        Err(e) => {
            set_last_error(format!("{e}"));
            std::ptr::null_mut()
        }
    }
}

/// Free a storage handle.
///
/// Does nothing if `storage` is null.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_storage_free(storage: *mut IcechunkStorage) {
    if !storage.is_null() {
        drop(unsafe { Box::from_raw(storage) });
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_in_memory_storage_roundtrip() {
        let ptr = icechunk_storage_new_in_memory();
        assert!(!ptr.is_null());
        unsafe { icechunk_storage_free(ptr) };
    }

    #[test]
    fn test_local_filesystem_storage() {
        let tmp = tempfile::tempdir().unwrap();
        let path = std::ffi::CString::new(
            tmp.path().to_str().unwrap()
        ).unwrap();
        let ptr = unsafe {
            icechunk_storage_new_local_filesystem(path.as_ptr())
        };
        assert!(!ptr.is_null());
        unsafe { icechunk_storage_free(ptr) };
    }

    #[test]
    fn test_null_path_returns_null() {
        let ptr = unsafe {
            icechunk_storage_new_local_filesystem(std::ptr::null())
        };
        assert!(ptr.is_null());
        let err = unsafe { icechunk_last_error() };
        assert!(!err.is_null());
    }

    #[test]
    fn test_free_null_is_safe() {
        unsafe { icechunk_storage_free(std::ptr::null_mut()) };
    }
}
```

**Step 2: Add `tempfile` dev-dependency to `icechunk-c/Cargo.toml`**

Add under `[dev-dependencies]`:

```toml
[dev-dependencies]
tempfile = "3"
```

**Step 3: Add module to `icechunk-c/src/lib.rs`**

```rust
//! C FFI bindings for the Icechunk Zarr store.

#![allow(clippy::missing_safety_doc)]

pub mod error;
mod runtime;
pub mod storage;
```

**Step 4: Run tests**

Run: `cargo nextest run -p icechunk-c`
Expected: 8 tests pass.

**Step 5: Commit**

```bash
git add icechunk-c/
git commit -m "feat(icechunk-c): add storage constructors with opaque pointers"
```

---

### Task 4: Store open/free and basic capability queries

**Files:**
- Create: `icechunk-c/src/store.rs`
- Modify: `icechunk-c/src/lib.rs`

This task creates the `IcechunkStore` opaque type, opens a store from storage on a branch, and exposes the simple capability queries.

**Step 1: Create `icechunk-c/src/store.rs`**

```rust
//! Opaque Zarr store handle and operations.

use std::collections::HashMap;
use std::ffi::CStr;
use std::sync::Arc;

use icechunk::repository::VersionInfo;
use icechunk::{Repository, Store};
use tokio::sync::RwLock;

use crate::error::*;
use crate::storage::IcechunkStorage;

/// Opaque handle to an Icechunk Zarr store.
pub struct IcechunkStore {
    pub(crate) inner: Store,
    // Keep the repo alive so storage is not dropped.
    pub(crate) _repo: Repository,
}

/// Open a store on the tip of a branch.
///
/// `storage` is consumed (freed) by this call — do NOT call
/// `icechunk_storage_free` on it afterwards.
///
/// `branch` must be a valid null-terminated UTF-8 string.
/// Returns null on failure.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_open(
    storage: *mut IcechunkStorage,
    branch: *const libc::c_char,
) -> *mut IcechunkStore {
    clear_last_error();

    if storage.is_null() {
        set_last_error("storage must not be null".to_string());
        return std::ptr::null_mut();
    }
    if branch.is_null() {
        set_last_error("branch must not be null".to_string());
        return std::ptr::null_mut();
    }

    let storage_box = unsafe { Box::from_raw(storage) };
    let branch_str = match unsafe { CStr::from_ptr(branch) }.to_str() {
        Ok(s) => s.to_owned(),
        Err(e) => {
            set_last_error(format!("invalid UTF-8 in branch: {e}"));
            return std::ptr::null_mut();
        }
    };

    crate::runtime::block_on(async {
        // Create or open the repository.
        let repo = match Repository::create(
            None,
            storage_box.inner,
            HashMap::new(),
            None,
        )
        .await
        {
            Ok(r) => r,
            Err(e) => {
                // If creation fails (repo already exists), try open.
                match Repository::open(
                    None,
                    // We can't reuse storage_box.inner because we moved it.
                    // This is a design issue — see note below.
                    // For now, we propagate the create error.
                    // TODO: refactor to try open first, then create.
                    return std::ptr::null_mut(),
                )
                .await
                {
                    _ => {
                        set_last_error(format!("failed to create repository: {e}"));
                        return std::ptr::null_mut();
                    }
                }
            }
        };

        let session = match repo.writable_session(&branch_str).await {
            Ok(s) => s,
            Err(e) => {
                set_last_error(format!("failed to open session: {e}"));
                return std::ptr::null_mut();
            }
        };

        let session = Arc::new(RwLock::new(session));
        let store = Store::from_session(session).await;

        Box::into_raw(Box::new(IcechunkStore {
            inner: store,
            _repo: repo,
        }))
    })
}

/// Free a store handle.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_free(store: *mut IcechunkStore) {
    if !store.is_null() {
        drop(unsafe { Box::from_raw(store) });
    }
}

/// Returns 1 if the store is read-only, 0 if writable, or negative on error.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_is_read_only(
    store: *const IcechunkStore,
) -> i32 {
    clear_last_error();
    if store.is_null() {
        set_last_error("store must not be null".to_string());
        return ICECHUNK_ERROR_NULL_ARGUMENT;
    }
    let store = unsafe { &*store };
    crate::runtime::block_on(async {
        if store.inner.read_only().await { 1 } else { 0 }
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_test_store() -> *mut IcechunkStore {
        let storage = crate::storage::icechunk_storage_new_in_memory();
        let branch = std::ffi::CString::new("main").unwrap();
        unsafe { icechunk_store_open(storage, branch.as_ptr()) }
    }

    #[test]
    fn test_store_open_and_free() {
        let store = make_test_store();
        assert!(!store.is_null());
        unsafe { icechunk_store_free(store) };
    }

    #[test]
    fn test_store_is_writable() {
        let store = make_test_store();
        assert!(!store.is_null());
        let ro = unsafe { icechunk_store_is_read_only(store) };
        assert_eq!(ro, 0); // writable
        unsafe { icechunk_store_free(store) };
    }

    #[test]
    fn test_store_null_args() {
        let branch = std::ffi::CString::new("main").unwrap();
        let ptr = unsafe { icechunk_store_open(std::ptr::null_mut(), branch.as_ptr()) };
        assert!(ptr.is_null());

        let storage = crate::storage::icechunk_storage_new_in_memory();
        let ptr = unsafe { icechunk_store_open(storage, std::ptr::null()) };
        assert!(ptr.is_null());
    }
}
```

**Important note:** The `icechunk_store_open` function above has a known issue with the create-vs-open logic. We need to check how `Repository::open` works (it requires storage separately). A cleaner approach: provide two separate functions — `icechunk_store_create` (for new repos) and `icechunk_store_open_existing` (for existing repos). Alternatively, use an `open_or_create` pattern. This should be resolved during implementation by studying `Repository::create` vs `Repository::open` signatures.

**Step 2: Add module to `icechunk-c/src/lib.rs`**

```rust
//! C FFI bindings for the Icechunk Zarr store.

#![allow(clippy::missing_safety_doc)]

pub mod error;
mod runtime;
pub mod storage;
pub mod store;
```

**Step 3: Run tests**

Run: `cargo nextest run -p icechunk-c`
Expected: 11+ tests pass. If the `store_open` compilation has issues with `Repository::open` signature, adjust the implementation to match the actual API — the key pattern is: create repo, create writable session, wrap in Store.

**Step 4: Commit**

```bash
git add icechunk-c/
git commit -m "feat(icechunk-c): add store open/free and read-only query"
```

---

### Task 5: Store `get` — read chunk data

**Files:**
- Modify: `icechunk-c/src/store.rs`

**Step 1: Add the `icechunk_store_get` function**

Add to `store.rs`:

```rust
/// Get the value for a Zarr key.
///
/// On success, returns `ICECHUNK_SUCCESS`, sets `*out_data` to a `malloc`-allocated
/// buffer and `*out_len` to its length. Caller must `free()` the buffer.
///
/// On failure, returns a negative error code. `*out_data` is set to null.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_get(
    store: *const IcechunkStore,
    key: *const libc::c_char,
    out_data: *mut *mut u8,
    out_len: *mut libc::size_t,
) -> i32 {
    clear_last_error();

    if store.is_null() || key.is_null() || out_data.is_null() || out_len.is_null() {
        set_last_error("null argument".to_string());
        if !out_data.is_null() {
            unsafe { *out_data = std::ptr::null_mut() };
        }
        return ICECHUNK_ERROR_NULL_ARGUMENT;
    }

    let store_ref = unsafe { &*store };
    let key_str = match unsafe { CStr::from_ptr(key) }.to_str() {
        Ok(s) => s,
        Err(e) => {
            set_last_error(format!("invalid UTF-8 in key: {e}"));
            unsafe { *out_data = std::ptr::null_mut() };
            return ICECHUNK_ERROR;
        }
    };

    let byte_range = icechunk::format::ByteRange::ALL;

    match crate::runtime::block_on(store_ref.inner.get(key_str, &byte_range)) {
        Ok(bytes) => {
            let len = bytes.len();
            if len == 0 {
                unsafe {
                    *out_data = std::ptr::null_mut();
                    *out_len = 0;
                };
                return ICECHUNK_SUCCESS;
            }
            let buf = unsafe { libc::malloc(len) as *mut u8 };
            if buf.is_null() {
                set_last_error("malloc failed".to_string());
                return ICECHUNK_ERROR;
            }
            unsafe {
                std::ptr::copy_nonoverlapping(bytes.as_ptr(), buf, len);
                *out_data = buf;
                *out_len = len;
            };
            ICECHUNK_SUCCESS
        }
        Err(e) => {
            unsafe { *out_data = std::ptr::null_mut() };
            let code = if e.to_string().contains("not found")
                || e.to_string().contains("NotFound")
            {
                ICECHUNK_ERROR_NOT_FOUND
            } else {
                ICECHUNK_ERROR
            };
            set_last_error(format!("{e}"));
            code
        }
    }
}
```

**Step 2: Write test for get**

Add to the `tests` module in `store.rs`:

```rust
#[test]
fn test_store_get_not_found() {
    let store = make_test_store();
    assert!(!store.is_null());

    let key = std::ffi::CString::new("nonexistent/zarr.json").unwrap();
    let mut data: *mut u8 = std::ptr::null_mut();
    let mut len: libc::size_t = 0;

    let rc = unsafe {
        icechunk_store_get(store, key.as_ptr(), &mut data, &mut len)
    };
    assert!(rc < 0); // should be not found or error
    assert!(data.is_null());

    unsafe { icechunk_store_free(store) };
}
```

**Step 3: Run tests**

Run: `cargo nextest run -p icechunk-c`
Expected: All tests pass.

**Step 4: Commit**

```bash
git add icechunk-c/
git commit -m "feat(icechunk-c): add icechunk_store_get"
```

---

### Task 6: Store `set` — write chunk data

**Files:**
- Modify: `icechunk-c/src/store.rs`

**Step 1: Add the `icechunk_store_set` function**

```rust
/// Set the value for a Zarr key.
///
/// `data` is a pointer to `len` bytes. The data is copied; the caller
/// retains ownership of the buffer.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_set(
    store: *const IcechunkStore,
    key: *const libc::c_char,
    data: *const u8,
    len: libc::size_t,
) -> i32 {
    clear_last_error();

    if store.is_null() || key.is_null() {
        set_last_error("null argument".to_string());
        return ICECHUNK_ERROR_NULL_ARGUMENT;
    }
    if data.is_null() && len > 0 {
        set_last_error("data is null but len > 0".to_string());
        return ICECHUNK_ERROR_NULL_ARGUMENT;
    }

    let store_ref = unsafe { &*store };
    let key_str = match unsafe { CStr::from_ptr(key) }.to_str() {
        Ok(s) => s,
        Err(e) => {
            set_last_error(format!("invalid UTF-8 in key: {e}"));
            return ICECHUNK_ERROR;
        }
    };

    let bytes = if len == 0 {
        bytes::Bytes::new()
    } else {
        let slice = unsafe { std::slice::from_raw_parts(data, len) };
        bytes::Bytes::copy_from_slice(slice)
    };

    match crate::runtime::block_on(store_ref.inner.set(key_str, bytes)) {
        Ok(()) => ICECHUNK_SUCCESS,
        Err(e) => {
            set_last_error(format!("{e}"));
            ICECHUNK_ERROR
        }
    }
}
```

**Step 2: Write a round-trip test (set then get)**

```rust
#[test]
fn test_store_set_and_get_roundtrip() {
    let store = make_test_store();
    assert!(!store.is_null());

    // First set zarr.json metadata so the array exists
    let meta_key = std::ffi::CString::new("array/zarr.json").unwrap();
    let meta = br#"{"zarr_format":3,"node_type":"array","shape":[4],"data_type":"float32","chunk_grid":{"name":"regular","configuration":{"chunk_shape":[4]}},"chunk_key_encoding":{"name":"default","configuration":{"separator":"/"}},"fill_value":0.0,"codecs":[{"name":"bytes","configuration":{"endian":"little"}}]}"#;
    let rc = unsafe {
        icechunk_store_set(store, meta_key.as_ptr(), meta.as_ptr(), meta.len())
    };
    assert_eq!(rc, ICECHUNK_SUCCESS);

    // Now set a chunk
    let key = std::ffi::CString::new("array/c/0").unwrap();
    let payload: [u8; 16] = [0, 0, 128, 63, 0, 0, 0, 64, 0, 0, 64, 64, 0, 0, 128, 64]; // [1.0f32, 2.0, 3.0, 4.0] little-endian
    let rc = unsafe {
        icechunk_store_set(store, key.as_ptr(), payload.as_ptr(), payload.len())
    };
    assert_eq!(rc, ICECHUNK_SUCCESS);

    // Read it back
    let mut data: *mut u8 = std::ptr::null_mut();
    let mut len: libc::size_t = 0;
    let rc = unsafe {
        icechunk_store_get(store, key.as_ptr(), &mut data, &mut len)
    };
    assert_eq!(rc, ICECHUNK_SUCCESS);
    assert_eq!(len, 16);
    assert!(!data.is_null());

    let result = unsafe { std::slice::from_raw_parts(data, len) };
    assert_eq!(result, &payload);

    unsafe { libc::free(data as *mut libc::c_void) };
    unsafe { icechunk_store_free(store) };
}
```

**Step 3: Run tests**

Run: `cargo nextest run -p icechunk-c`
Expected: All tests pass.

**Step 4: Commit**

```bash
git add icechunk-c/
git commit -m "feat(icechunk-c): add icechunk_store_set with round-trip test"
```

---

### Task 7: Store `delete`, `exists`

**Files:**
- Modify: `icechunk-c/src/store.rs`

**Step 1: Add `icechunk_store_exists`**

```rust
/// Check if a key exists.
///
/// Returns 1 if the key exists, 0 if not, or negative on error.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_exists(
    store: *const IcechunkStore,
    key: *const libc::c_char,
) -> i32 {
    clear_last_error();
    if store.is_null() || key.is_null() {
        set_last_error("null argument".to_string());
        return ICECHUNK_ERROR_NULL_ARGUMENT;
    }

    let store_ref = unsafe { &*store };
    let key_str = match unsafe { CStr::from_ptr(key) }.to_str() {
        Ok(s) => s,
        Err(e) => {
            set_last_error(format!("invalid UTF-8 in key: {e}"));
            return ICECHUNK_ERROR;
        }
    };

    match crate::runtime::block_on(store_ref.inner.exists(key_str)) {
        Ok(true) => 1,
        Ok(false) => 0,
        Err(e) => {
            set_last_error(format!("{e}"));
            ICECHUNK_ERROR
        }
    }
}
```

**Step 2: Add `icechunk_store_delete`**

```rust
/// Delete a key.
///
/// Returns `ICECHUNK_SUCCESS` on success (including if key didn't exist).
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_delete(
    store: *const IcechunkStore,
    key: *const libc::c_char,
) -> i32 {
    clear_last_error();
    if store.is_null() || key.is_null() {
        set_last_error("null argument".to_string());
        return ICECHUNK_ERROR_NULL_ARGUMENT;
    }

    let store_ref = unsafe { &*store };
    let key_str = match unsafe { CStr::from_ptr(key) }.to_str() {
        Ok(s) => s,
        Err(e) => {
            set_last_error(format!("invalid UTF-8 in key: {e}"));
            return ICECHUNK_ERROR;
        }
    };

    match crate::runtime::block_on(store_ref.inner.delete(key_str)) {
        Ok(()) => ICECHUNK_SUCCESS,
        Err(e) => {
            set_last_error(format!("{e}"));
            ICECHUNK_ERROR
        }
    }
}
```

**Step 3: Write tests**

```rust
#[test]
fn test_exists_and_delete() {
    let store = make_test_store();

    // Set up an array with metadata
    let meta_key = std::ffi::CString::new("arr/zarr.json").unwrap();
    let meta = br#"{"zarr_format":3,"node_type":"array","shape":[1],"data_type":"int32","chunk_grid":{"name":"regular","configuration":{"chunk_shape":[1]}},"chunk_key_encoding":{"name":"default","configuration":{"separator":"/"}},"fill_value":0,"codecs":[{"name":"bytes","configuration":{"endian":"little"}}]}"#;
    unsafe { icechunk_store_set(store, meta_key.as_ptr(), meta.as_ptr(), meta.len()) };

    let key = std::ffi::CString::new("arr/c/0").unwrap();
    let data = [1u8, 2, 3, 4];
    unsafe { icechunk_store_set(store, key.as_ptr(), data.as_ptr(), data.len()) };

    assert_eq!(unsafe { icechunk_store_exists(store, key.as_ptr()) }, 1);

    let rc = unsafe { icechunk_store_delete(store, key.as_ptr()) };
    assert_eq!(rc, ICECHUNK_SUCCESS);

    assert_eq!(unsafe { icechunk_store_exists(store, key.as_ptr()) }, 0);

    unsafe { icechunk_store_free(store) };
}
```

**Step 4: Run tests**

Run: `cargo nextest run -p icechunk-c`
Expected: All tests pass.

**Step 5: Commit**

```bash
git add icechunk-c/
git commit -m "feat(icechunk-c): add exists and delete operations"
```

---

### Task 8: List iterator (open/next/free)

**Files:**
- Modify: `icechunk-c/src/store.rs`

**Step 1: Add the iterator type and functions**

```rust
use futures::{StreamExt, stream::BoxStream};
use std::sync::Mutex;

/// Opaque iterator over key listings.
pub struct IcechunkStoreListIter {
    stream: Mutex<BoxStream<'static, icechunk::store::StoreResult<String>>>,
}

/// Begin listing all keys in the store.
///
/// Returns null on failure.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_list(
    store: *const IcechunkStore,
) -> *mut IcechunkStoreListIter {
    clear_last_error();
    if store.is_null() {
        set_last_error("store must not be null".to_string());
        return std::ptr::null_mut();
    }
    let store_ref = unsafe { &*store };

    match crate::runtime::block_on(store_ref.inner.list()) {
        Ok(stream) => {
            let boxed = stream.boxed();
            Box::into_raw(Box::new(IcechunkStoreListIter {
                stream: Mutex::new(boxed),
            }))
        }
        Err(e) => {
            set_last_error(format!("{e}"));
            std::ptr::null_mut()
        }
    }
}

/// Begin listing keys under a prefix.
///
/// `prefix` must be a valid null-terminated UTF-8 string.
/// Returns null on failure.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_list_prefix(
    store: *const IcechunkStore,
    prefix: *const libc::c_char,
) -> *mut IcechunkStoreListIter {
    clear_last_error();
    if store.is_null() || prefix.is_null() {
        set_last_error("null argument".to_string());
        return std::ptr::null_mut();
    }
    let store_ref = unsafe { &*store };
    let prefix_str = match unsafe { CStr::from_ptr(prefix) }.to_str() {
        Ok(s) => s,
        Err(e) => {
            set_last_error(format!("invalid UTF-8 in prefix: {e}"));
            return std::ptr::null_mut();
        }
    };

    match crate::runtime::block_on(store_ref.inner.list_prefix(prefix_str)) {
        Ok(stream) => {
            let boxed = stream.boxed();
            Box::into_raw(Box::new(IcechunkStoreListIter {
                stream: Mutex::new(boxed),
            }))
        }
        Err(e) => {
            set_last_error(format!("{e}"));
            std::ptr::null_mut()
        }
    }
}

/// Begin listing directory contents under a prefix.
///
/// `prefix` must be a valid null-terminated UTF-8 string.
/// Returns null on failure.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_list_dir(
    store: *const IcechunkStore,
    prefix: *const libc::c_char,
) -> *mut IcechunkStoreListIter {
    clear_last_error();
    if store.is_null() || prefix.is_null() {
        set_last_error("null argument".to_string());
        return std::ptr::null_mut();
    }
    let store_ref = unsafe { &*store };
    let prefix_str = match unsafe { CStr::from_ptr(prefix) }.to_str() {
        Ok(s) => s,
        Err(e) => {
            set_last_error(format!("invalid UTF-8 in prefix: {e}"));
            return std::ptr::null_mut();
        }
    };

    match crate::runtime::block_on(store_ref.inner.list_dir(prefix_str)) {
        Ok(stream) => {
            let boxed = stream.boxed();
            Box::into_raw(Box::new(IcechunkStoreListIter {
                stream: Mutex::new(boxed),
            }))
        }
        Err(e) => {
            set_last_error(format!("{e}"));
            std::ptr::null_mut()
        }
    }
}

/// Get the next key from a list iterator.
///
/// On success, returns `ICECHUNK_SUCCESS` and sets `*out_key` to a
/// `malloc`-allocated null-terminated string. Caller must `free()` it.
///
/// When iteration is exhausted, returns `ICECHUNK_SUCCESS` and
/// sets `*out_key` to null.
///
/// On error, returns negative code.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_list_next(
    iter: *mut IcechunkStoreListIter,
    out_key: *mut *mut libc::c_char,
) -> i32 {
    clear_last_error();
    if iter.is_null() || out_key.is_null() {
        set_last_error("null argument".to_string());
        return ICECHUNK_ERROR_NULL_ARGUMENT;
    }

    let iter_ref = unsafe { &*iter };
    let mut stream = iter_ref.stream.lock().unwrap();

    match crate::runtime::block_on(stream.next()) {
        None => {
            // Iteration complete.
            unsafe { *out_key = std::ptr::null_mut() };
            ICECHUNK_SUCCESS
        }
        Some(Ok(key)) => {
            let len = key.len();
            let buf = unsafe { libc::malloc(len + 1) as *mut libc::c_char };
            if buf.is_null() {
                set_last_error("malloc failed".to_string());
                return ICECHUNK_ERROR;
            }
            unsafe {
                std::ptr::copy_nonoverlapping(
                    key.as_ptr() as *const libc::c_char,
                    buf,
                    len,
                );
                *buf.add(len) = 0; // null terminator
                *out_key = buf;
            };
            ICECHUNK_SUCCESS
        }
        Some(Err(e)) => {
            unsafe { *out_key = std::ptr::null_mut() };
            set_last_error(format!("{e}"));
            ICECHUNK_ERROR
        }
    }
}

/// Free a list iterator.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn icechunk_store_list_free(
    iter: *mut IcechunkStoreListIter,
) {
    if !iter.is_null() {
        drop(unsafe { Box::from_raw(iter) });
    }
}
```

**Step 2: Write test for list iterator**

```rust
#[test]
fn test_list_empty_store() {
    let store = make_test_store();
    let iter = unsafe { icechunk_store_list(store) };
    assert!(!iter.is_null());

    let mut key: *mut libc::c_char = std::ptr::null_mut();
    let rc = unsafe { icechunk_store_list_next(iter, &mut key) };
    assert_eq!(rc, ICECHUNK_SUCCESS);
    assert!(key.is_null()); // empty store

    unsafe { icechunk_store_list_free(iter) };
    unsafe { icechunk_store_free(store) };
}

#[test]
fn test_list_after_set() {
    let store = make_test_store();

    // Create an array with metadata
    let meta_key = std::ffi::CString::new("myarray/zarr.json").unwrap();
    let meta = br#"{"zarr_format":3,"node_type":"array","shape":[2],"data_type":"int32","chunk_grid":{"name":"regular","configuration":{"chunk_shape":[1]}},"chunk_key_encoding":{"name":"default","configuration":{"separator":"/"}},"fill_value":0,"codecs":[{"name":"bytes","configuration":{"endian":"little"}}]}"#;
    unsafe { icechunk_store_set(store, meta_key.as_ptr(), meta.as_ptr(), meta.len()) };

    let key0 = std::ffi::CString::new("myarray/c/0").unwrap();
    let key1 = std::ffi::CString::new("myarray/c/1").unwrap();
    let data = [0u8; 4];
    unsafe { icechunk_store_set(store, key0.as_ptr(), data.as_ptr(), data.len()) };
    unsafe { icechunk_store_set(store, key1.as_ptr(), data.as_ptr(), data.len()) };

    // List all keys
    let iter = unsafe { icechunk_store_list(store) };
    assert!(!iter.is_null());

    let mut keys = Vec::new();
    loop {
        let mut key: *mut libc::c_char = std::ptr::null_mut();
        let rc = unsafe { icechunk_store_list_next(iter, &mut key) };
        assert_eq!(rc, ICECHUNK_SUCCESS);
        if key.is_null() {
            break;
        }
        let s = unsafe { CStr::from_ptr(key) }.to_str().unwrap().to_owned();
        unsafe { libc::free(key as *mut libc::c_void) };
        keys.push(s);
    }

    // Should have at least the zarr.json and 2 chunks
    assert!(keys.len() >= 3, "expected at least 3 keys, got: {keys:?}");

    unsafe { icechunk_store_list_free(iter) };
    unsafe { icechunk_store_free(store) };
}
```

**Step 3: Run tests**

Run: `cargo nextest run -p icechunk-c`
Expected: All tests pass.

**Step 4: Commit**

```bash
git add icechunk-c/
git commit -m "feat(icechunk-c): add list iterator (open/next/free pattern)"
```

---

### Task 9: C header generation with `cbindgen`

**Files:**
- Create: `icechunk-c/build.rs`

**Step 1: Create `icechunk-c/build.rs`**

```rust
fn main() {
    let crate_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let config = cbindgen::Config::from_file("cbindgen.toml")
        .unwrap_or_default();

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_config(config)
        .generate()
        .expect("Unable to generate C bindings")
        .write_to_file("include/icechunk.h");
}
```

**Step 2: Create the output directory**

Run: `mkdir -p icechunk-c/include`

**Step 3: Build and verify header is generated**

Run: `cargo build -p icechunk-c`
Then: `cat icechunk-c/include/icechunk.h`
Expected: A C header with all `icechunk_*` function declarations.

**Step 4: Commit**

```bash
git add icechunk-c/build.rs icechunk-c/include/
git commit -m "feat(icechunk-c): generate C header with cbindgen"
```

---

### Task 10: Integration smoke test from C

**Files:**
- Create: `icechunk-c/tests/smoke_test.c`
- Modify: `icechunk-c/Cargo.toml` (add integration test runner if needed)

**Step 1: Create `icechunk-c/tests/smoke_test.c`**

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../include/icechunk.h"

int main(void) {
    /* Create in-memory storage */
    IcechunkStorage *storage = icechunk_storage_new_in_memory();
    assert(storage != NULL);

    /* Open a store on "main" branch */
    IcechunkStore *store = icechunk_store_open(storage, "main");
    assert(store != NULL);

    /* Verify it's writable */
    assert(icechunk_store_is_read_only(store) == 0);

    /* Set zarr.json metadata */
    const char *meta_key = "myarray/zarr.json";
    const char *meta = "{\"zarr_format\":3,\"node_type\":\"array\",\"shape\":[4],\"data_type\":\"float32\",\"chunk_grid\":{\"name\":\"regular\",\"configuration\":{\"chunk_shape\":[4]}},\"chunk_key_encoding\":{\"name\":\"default\",\"configuration\":{\"separator\":\"/\"}},\"fill_value\":0.0,\"codecs\":[{\"name\":\"bytes\",\"configuration\":{\"endian\":\"little\"}}]}";
    int rc = icechunk_store_set(store, meta_key, (const uint8_t *)meta, strlen(meta));
    assert(rc == 0);

    /* Set a chunk */
    const char *chunk_key = "myarray/c/0";
    uint8_t chunk_data[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
    rc = icechunk_store_set(store, chunk_key, chunk_data, sizeof(chunk_data));
    assert(rc == 0);

    /* Verify it exists */
    assert(icechunk_store_exists(store, chunk_key) == 1);

    /* Read it back */
    uint8_t *out_data = NULL;
    size_t out_len = 0;
    rc = icechunk_store_get(store, chunk_key, &out_data, &out_len);
    assert(rc == 0);
    assert(out_len == sizeof(chunk_data));
    assert(memcmp(out_data, chunk_data, out_len) == 0);
    free(out_data);

    /* List keys */
    IcechunkStoreListIter *iter = icechunk_store_list(store);
    assert(iter != NULL);
    int count = 0;
    while (1) {
        char *key = NULL;
        rc = icechunk_store_list_next(iter, &key);
        assert(rc == 0);
        if (key == NULL) break;
        printf("  key: %s\n", key);
        free(key);
        count++;
    }
    assert(count >= 2); /* at least zarr.json + chunk */
    icechunk_store_list_free(iter);

    /* Delete the chunk */
    rc = icechunk_store_delete(store, chunk_key);
    assert(rc == 0);
    assert(icechunk_store_exists(store, chunk_key) == 0);

    /* Error message should be null when no error */
    assert(icechunk_last_error() == NULL);

    /* Cleanup */
    icechunk_store_free(store);

    printf("All C smoke tests passed!\n");
    return 0;
}
```

**Step 2: Build and run the C test**

This requires linking against the built library. The exact commands depend on platform:

```bash
# Build the C library first
cargo build -p icechunk-c

# Compile and link the C test (macOS)
cc -o icechunk-c/tests/smoke_test \
   icechunk-c/tests/smoke_test.c \
   -L target/debug \
   -licechunk_c \
   -framework Security -framework CoreFoundation

# Run it
./icechunk-c/tests/smoke_test
```

Expected: "All C smoke tests passed!"

**Step 3: Commit**

```bash
git add icechunk-c/tests/
git commit -m "test(icechunk-c): add C integration smoke test"
```

---

## Future Work (not in this MVP)

These are explicitly out of scope for this plan but noted for future extension:

- **Session layer**: `icechunk_session_commit`, `icechunk_session_rebase`, conflict resolution
- **Repository layer**: `icechunk_repo_create_branch`, `icechunk_repo_create_tag`, `icechunk_repo_history`
- **S3/GCS/Azure storage constructors**: credential configuration
- **`get_partial_values`**: batch retrieval with byte ranges
- **ByteRange support in `get`**: expose offset/length parameters
- **`list_dir_items`**: return typed enum (Key vs Prefix) instead of flat strings
- **Async/callback API**: for non-blocking usage
- **Julia wrapper package**: high-level Julia types wrapping these C functions
