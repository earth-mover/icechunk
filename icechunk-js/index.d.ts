/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Repository {
  static create(storage: JsStorage, config?: RepositoryConfig | undefined | null, specVersion?: number | undefined | null, authorizeVirtualChunkAccess?: Record<string, JsCredentials | undefined | null> | undefined | null): Promise<Repository>
  static open(storage: JsStorage, config?: RepositoryConfig | undefined | null, authorizeVirtualChunkAccess?: Record<string, JsCredentials | undefined | null> | undefined | null): Promise<Repository>
  static openOrCreate(storage: JsStorage, config?: RepositoryConfig | undefined | null, specVersion?: number | undefined | null, authorizeVirtualChunkAccess?: Record<string, JsCredentials | undefined | null> | undefined | null): Promise<Repository>
  static exists(storage: JsStorage): Promise<boolean>
  readonlySession(options?: ReadonlySessionOptions | undefined | null): Promise<JsSession>
  writableSession(branch: string): Promise<JsSession>
  listBranches(): Promise<Array<string>>
  createBranch(name: string, snapshotId: string): Promise<void>
  listTags(): Promise<Array<string>>
  createTag(name: string, snapshotId: string): Promise<void>
  lookupManifestFiles(snapshotId: string): Promise<Array<JsManifestFileInfo>>
}
export type JsRepository = Repository

export declare class Session {
  get readOnly(): boolean
  get snapshotId(): string
  get branch(): string | null
  get hasUncommittedChanges(): boolean
  get store(): JsStore
  commit(message: string): Promise<string>
  discardChanges(): Promise<void>
}
export type JsSession = Session

export declare class Storage {
  static newInMemory(): Promise<Storage>
}
export type JsStorage = Storage

export declare class Store {
  get(key: string): Promise<Buffer | null>
  getRange(key: string, offset: number, length?: number | undefined | null): Promise<Buffer | null>
  set(key: string, value: Buffer): Promise<void>
  exists(key: string): Promise<boolean>
  delete(key: string): Promise<void>
  list(): Promise<Array<string>>
  listPrefix(prefix: string): Promise<Array<string>>
  listDir(prefix: string): Promise<Array<string>>
  get supportsWrites(): boolean
  get supportsDeletes(): boolean
  get supportsListing(): boolean
}
export type JsStore = Store

/** Caching configuration */
export interface CachingConfig {
  numSnapshotNodes?: number
  numChunkRefs?: number
  numTransactionChanges?: number
  numBytesAttributes?: number
  numBytesChunks?: number
}

/** Compression algorithm */
export declare const enum CompressionAlgorithm {
  Zstd = 0
}

/** Compression configuration */
export interface CompressionConfig {
  algorithm?: CompressionAlgorithm
  level?: number
}

export interface ManifestFileInfo {
  id: string
  sizeBytes: number
  numChunkRefs: number
}

export interface ReadonlySessionOptions {
  branch?: string
  tag?: string
  snapshotId?: string
}

/** Repository configuration (WASM build â€” no virtual chunk support) */
export interface RepositoryConfig {
  inlineChunkThresholdBytes?: number
  getPartialValuesConcurrency?: number
  compression?: CompressionConfig
  maxConcurrentRequests?: number
  caching?: CachingConfig
  storage?: StorageSettings
  /**
   * Manifest configuration, passed as a JSON-compatible object.
   * The object is deserialized using serde, matching the Rust ManifestConfig structure.
   */
  manifest?: any
}

/** Storage concurrency settings */
export interface StorageConcurrencySettings {
  maxConcurrentRequestsForObject?: number
  idealConcurrentRequestSize?: number
}

/** Storage retries settings */
export interface StorageRetriesSettings {
  maxTries?: number
  initialBackoffMs?: number
  maxBackoffMs?: number
}

/** Storage settings */
export interface StorageSettings {
  concurrency?: StorageConcurrencySettings
  retries?: StorageRetriesSettings
  unsafeUseConditionalUpdate?: boolean
  unsafeUseConditionalCreate?: boolean
  unsafeUseMetadata?: boolean
  storageClass?: string
  metadataStorageClass?: string
  chunksStorageClass?: string
  minimumSizeForMultipartUpload?: number
}
