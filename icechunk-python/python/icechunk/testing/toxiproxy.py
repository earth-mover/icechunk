"""
Thin synchronous client for the Toxiproxy HTTP API.

Completely generated by Claude Code. This code is not precious.
"""

from __future__ import annotations

import json
import logging
import urllib.request
from dataclasses import dataclass

logger = logging.getLogger(__name__)

# --- Toxic dataclasses ---


@dataclass
class Latency:
    """Add latency to data."""

    name: str
    latency_ms: int
    jitter_ms: int = 0
    stream: str = "downstream"
    toxicity: float = 1.0

    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "type": "latency",
            "stream": self.stream,
            "toxicity": self.toxicity,
            "attributes": {"latency": self.latency_ms, "jitter": self.jitter_ms},
        }


@dataclass
class Bandwidth:
    """Limit bandwidth to rate KB/s."""

    name: str
    rate_kbps: int
    stream: str = "downstream"
    toxicity: float = 1.0

    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "type": "bandwidth",
            "stream": self.stream,
            "toxicity": self.toxicity,
            "attributes": {"rate": self.rate_kbps},
        }


@dataclass
class Slicer:
    """Slice data into small bits."""

    name: str
    average_size_bytes: int
    size_variation_bytes: int = 0
    delay_us: int = 0
    stream: str = "downstream"
    toxicity: float = 1.0

    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "type": "slicer",
            "stream": self.stream,
            "toxicity": self.toxicity,
            "attributes": {
                "average_size": self.average_size_bytes,
                "size_variation": self.size_variation_bytes,
                "delay": self.delay_us,
            },
        }


@dataclass
class SlowClose:
    """Delay the close of the connection."""

    name: str
    delay_ms: int
    stream: str = "downstream"
    toxicity: float = 1.0

    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "type": "slow_close",
            "stream": self.stream,
            "toxicity": self.toxicity,
            "attributes": {"delay": self.delay_ms},
        }


@dataclass
class Timeout:
    """Stop all data and close after timeout. Set to 0 to close immediately."""

    name: str
    timeout_ms: int
    stream: str = "downstream"
    toxicity: float = 1.0

    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "type": "timeout",
            "stream": self.stream,
            "toxicity": self.toxicity,
            "attributes": {"timeout": self.timeout_ms},
        }


@dataclass
class ResetPeer:
    """Simulate TCP RST after timeout. Set to 0 to reset immediately."""

    name: str
    timeout_ms: int
    stream: str = "downstream"
    toxicity: float = 1.0

    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "type": "reset_peer",
            "stream": self.stream,
            "toxicity": self.toxicity,
            "attributes": {"timeout": self.timeout_ms},
        }


@dataclass
class LimitData:
    """Close connection after transmitting bytes bytes."""

    name: str
    bytes: int
    stream: str = "downstream"
    toxicity: float = 1.0

    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "type": "limit_data",
            "stream": self.stream,
            "toxicity": self.toxicity,
            "attributes": {"bytes": self.bytes},
        }


Toxic = Latency | Bandwidth | Slicer | SlowClose | Timeout | ResetPeer | LimitData


# --- Client ---


class ToxiproxyClient:
    def __init__(self, host) -> None:
        self.host = host.rstrip("/")

    def _request(self, method: str, path: str, body: dict | None = None) -> dict | None:
        url = f"{self.host}{path}"
        data = json.dumps(body).encode() if body else None
        req = urllib.request.Request(url, data=data, method=method)
        req.add_header("Content-Type", "application/json")
        with urllib.request.urlopen(req) as resp:
            content = resp.read()
            if content:
                return json.loads(content)
        return None

    def create_proxy(self, name: str, listen: str, upstream: str) -> dict:
        logger.debug("create_proxy %s (%s -> %s)", name, listen, upstream)
        result = self._request(
            "POST",
            "/proxies",
            {"name": name, "listen": listen, "upstream": upstream, "enabled": True},
        )
        assert result is not None
        return result

    def delete_proxy(self, name: str) -> None:
        logger.debug("delete_proxy %s", name)
        self._request("DELETE", f"/proxies/{name}")

    def add_toxic(self, proxy_name: str, toxic: Toxic) -> dict:
        logger.debug("add_toxic %s/%s (%s)", proxy_name, toxic.name, type(toxic).__name__)
        result = self._request("POST", f"/proxies/{proxy_name}/toxics", toxic.to_dict())
        assert result is not None
        return result

    def remove_toxic(self, proxy_name: str, toxic_name: str) -> None:
        logger.debug("remove_toxic %s/%s", proxy_name, toxic_name)
        self._request("DELETE", f"/proxies/{proxy_name}/toxics/{toxic_name}")

    def reset(self) -> None:
        """Remove all toxics and re-enable all proxies."""
        logger.debug("reset")
        self._request("POST", "/reset")
